<!DOCTYPE html>
<html lang="en">
<head>

<style>
/* Modal styling */
.modal {
    display: none; /* Hide the modal by default */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5); /* Dark overlay */
    z-index: 100; /* Ensure it's on top */
}

.modal-content {
    background: white;
    margin: 10% auto;
    padding: 20px;
    width: 70%;
    border-radius: 5px;
    max-height: 80vh;
    overflow-y: auto;
}

/* Ensure labels and inputs don't wrap */
.modal-content label {
    display: inline-block;
    width: 200px; /* Set a fixed width for labels */
    font-weight: bold;
}

.modal-content input {
    width: calc(100% - 1100px); /* Take up remaining space for inputs */
    margin-top: 5px;
}


  /* Make Add Sale area non-scrollable */
  #monthlySalesModal .modal-content {
    display: flex;
    flex-direction: column;
    max-height: 80vh;
  }
  #monthlySalesModal .modal-header-flex,
  #monthlySalesModal .modal-content > h3,
  #monthlySalesModal .modal-content > button[onclick="closeMonthlySalesModal()"],
  #monthlySalesModal .modal-content > div[style] {
    flex: 0 0 auto;
  }
  #monthlySalesModal .modal-body {
    flex: 1 1 auto;
    overflow-y: auto;
  }

  /* Flex layout for Add Sale fields in Monthly Sales modal */
  /* Enforce Mijn Tafel Name width */
  #monthlySalesModal .modal-header-flex input#newSaleMijnTafelName {
    width: 190px !important;
  }
  /* Add spacing between Add Sale section and table */
  #monthlySalesModal .modal-body {
    margin-top: 15px !important;
  }

  /* Adjust Mijn Tafel Name width and add non-scrollable space */
  #monthlySalesModal .modal-header-flex {
    padding-bottom: 10px !important;
  }
  #monthlySalesModal .modal-header-flex input#newSaleMijnTafelName {
    width: 190px !important;
  }

  /* Reduce width of Mijn Tafel Name field to fit in one line */
  #monthlySalesModal .modal-header-flex input#newSaleMijnTafelName {
    width: 100px !important;
  }

  #monthlySalesModal .modal-header-flex {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: nowrap;
    overflow-x: auto;
    padding-bottom: 10px;
  }
  #monthlySalesModal .modal-header-flex select,
  #monthlySalesModal .modal-header-flex input,
  #monthlySalesModal .modal-header-flex button {
    flex: 0 0 auto;
  }

  /* Ensure Edit Order modal appears above Purchase History modal */
  #editPurchaseModal {
    z-index: 2000 !important;
  }
  #editPurchaseModal .modal-content {
    z-index: 2001 !important;
  }

  /* ==== Monthly Sales Modal Overrides ==== */
  #monthlySalesModal .modal-content {
    display: flex;
    flex-direction: column;
    height: 80vh; /* limit height */
  }
  #monthlySalesModal .modal-content > input,
  #monthlySalesModal .modal-content > select,
  #monthlySalesModal .modal-content > button[onclick^="addSaleFromModal"] {
    flex: 0 0 auto;
    margin: 5px;
  }
  #monthlySalesModal .modal-body {
    flex: 1 1 auto;
    overflow-y: auto;
  }
  

  /* Final override for Mijn Tafel Name width */
  #monthlySalesModal .modal-header-flex input#newSaleMijnTafelName {
    width: 190px !important;
  }
  /* Space table below header */
  #monthlySalesModal .modal-body {
    margin-top: 15px !important;
  }

  /* Increase Add Sale section height by 20px */
  #monthlySalesModal .modal-header-flex {
    padding-top: 0px !important;
  }

/* Add styling for Edit modal to match other modals */
#editRentalPaymentModal .modal-content {
    display: flex;
    flex-direction: column;
    max-height: 80vh;
}
#editRentalPaymentModal .modal-content > div {
    margin: 0px 0;
}
#editRentalPaymentModal .modal-content label {
    display: inline-block;
    width: 200px;
    font-weight: bold;
}
#editRentalPaymentModal .modal-content input {
    width: calc(100% - 1100px);
}
  #monthlySalesModal .modal-body td input[type="date"],
  #monthlySalesModal .modal-body td input[type="number"],
  #monthlySalesModal .modal-body td input[type="text"] {
      width: 100% !important;     /* fill the whole table cell            */
      min-width: 60px;            /* keep readable if the window is tiny  */
      box-sizing: border-box;     /* include padding/border inside 100 %  */
  }

<!-- Narrow the “Add Sale” inputs so the strip fits without scrolling -->
<style>
  /* text boxes (Item & Mijn Tafel Name) */
  #monthlySalesModal .modal-header-flex .wide-input {
      width: 160px !important;          /* was 300 px */
  }

  /* Date, Qty, Price and Table/Place */
  #monthlySalesModal .modal-header-flex input[type="date"]   { width: 120px !important; }
  #monthlySalesModal .modal-header-flex input[type="number"] { width:  80px !important; }
  #monthlySalesModal .modal-header-flex input[type="text"]:not(.wide-input) {
      width: 120px !important;          /* Table/Place */
  }

  /* OPTIONAL – if a tiny screen still overflows, allow the row to wrap */
  /* #monthlySalesModal .modal-header-flex { flex-wrap: wrap; overflow-x: visible; } */
</style>

<style>
/* === fixed sidebar =================================================== */
#sidebar {
    position:fixed;      /* sticks to the left edge */
    top:0;
    left:0;
    width:170px;
    height:100%;
    background:#2d2d2d;
    color:#fff;
    display:flex;
    flex-direction:column;
    padding:20px 0;
    box-sizing:border-box;
}

#sidebar a{
    color:#fff;
    text-decoration:none;
    padding:12px 20px;
    font-family:Arial, sans-serif;
    font-size:15px;
}

#sidebar a:hover,
#sidebar a.active{
    background:#444;
}

#mainContent{
    margin-left:170px;   /* pushes the existing app to the right */
    padding:0 20px;      /* keep your original 20-px body padding */
    box-sizing:border-box;
}
</style>


</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
    if (typeof XLSX === 'undefined') {
        document.write('<script src="https://unpkg.com/xlsx@0.20.2/dist/xlsx.full.min.js"><\/script>');
    }
</script>

<script>
    // Final check after fallbacks
    window.addEventListener('load', function() {
        if (typeof XLSX === 'undefined') {
            console.error('All XLSX library sources failed to load.');
        } else {
            console.log('XLSX library loaded successfully.');
        }
    });
</script>

    <meta charset="UTF-8">
    <title>Shop Tracker</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
/* Part 37: Ensure 1-line gap above Data Management tab */
div.tab#dataManagementSection {
    margin-top: 20px !important;
}
/* Part 37: Style buttons in Data Management tab */
div.tab#dataManagementSection button {
    font-family: Arial, sans-serif;
    padding: 10px 20px;
    margin: 10px 5px;
    background: #e0e0e0;
    border: none;
    border-radius: 3px;
    cursor: pointer;
}
/* Part 37: Hover effect for buttons */
div.tab#dataManagementSection button:hover {
    background: #d0d0d0;
}
</style>

  <!-- Hide the last (8th) column in Inventory and Sold Out / Zero Stock tables -->
  <style>
    #inventoryTable th:nth-child(8),
    #inventoryTable td:nth-child(8),
    #inventoryTable tr.filter-row th:nth-child(8),
    #soldOutTable th:nth-child(8),
    #soldOutTable td:nth-child(8),
    #soldOutTable tr.filter-row th:nth-child(8) {
      display: none !important;
    }
  </style>


<style>
/* Bottom-row buttons in the Monthly-Sales modal */
#monthlySalesModal #monthlySaveBtn,

/* put Save just to the left of Close */
#monthlySalesModal #monthlySaveBtn{ order: -1; }
</style>

<style>
/* bottom button bar */
#monthlySalesBtnRow{
    display:flex;
    justify-content:flex-start;   /* push buttons to the right */
    gap:10px;                   /* space between Save & Close */
    position:sticky;            /* stay visible while table scrolls */
    bottom:0;
    margin-top:auto;            /* push the bar to the very bottom of the column */
    padding:5px;
    background:#fff;            /* optional – keeps bar visible on scroll */
}
#monthlySalesBtnRow button{
    flex:0 0 auto;              /* never stretch full width */
    padding:5px 12px;
    font-size:14px;
}
</style>

<style>
/* Give Save Changes the same look as Close */
#monthlySaveBtn{
    background:#e0e0e0;   /* same light-grey fill                  */
    border:none;          /* remove default border                 */
    border-radius:3px;    /* same slight rounding as Close         */
}
/* Greyer when disabled */
#monthlySaveBtn:disabled{
    background:#bfbfbf;
}
</style>

<style>
/* Give Save Changes the same look as Close */
#recordSaleBtn{
    background:#e0e0e0;   /* same light-grey fill                  */
    border:none;          /* remove default border                 */
    border-radius:3px;    /* same slight rounding as Close         */
}
/* Greyer when disabled */
#recordSaleBtn:disabled{
    background:#bfbfbf;
}
</style>

<script>
function showPanel(name) {
  const shop = document.getElementById('shopPanel');
  const fab  = document.getElementById('fabriekPanel');
  const navShop    = document.getElementById('navShop');
  const navFabriek = document.getElementById('navFabriek');

  if (name === 'shop') {
    shop.style.display = '';
    fab .style.display = 'none';
    navShop.classList.add('active');
    navFabriek.classList.remove('active');
  } else {
    shop.style.display = 'none';
    fab .style.display = '';
    navFabriek.classList.add('active');
    navShop.classList.remove('active');
  }
}
</script>

<style>
  /* 1) Make the html/body fill the viewport */
  html, body {
    margin: 0;
    height: 100%;
  }

  /* 2) Sidebar stays full-height */
  #sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 170px;   /* whatever width you chose */
    height: 100%;
  }

  /* 3) Main content sits to the right of the sidebar and fills the rest */
  #mainContent {
    margin-left: 170px;  /* same as sidebar width */
    height: 100%;
    position: relative;
    overflow: hidden;    /* don’t let its children escape */
  }

  /* 4) Both panels (shopPanel & fabriekPanel) should fill all of #mainContent */
  #shopPanel,
  #fabriekPanel {
    height: 100%;
    overflow: auto;      /* if their content overflows, scroll inside them */
  }

  /* 5) And finally, make the iframe itself fill its panel */
  #fabriekPanel iframe {
    width: 100%;
    height: 100%;
    border: none;
    display: block;
  }
</style>

<style>
    #addPrintsTable td input[type="checkbox"] {
      transform: scale(1.0);
      margin: auto;
      display: block;
    }
  </style>  

</head>
<body>

<!-- sidebar -->
<nav id="sidebar">
  <a href="#"
     id="navShop"
     class="active"
     onclick="showPanel('shop'); return false;">
    Shop Tracker
  </a>
  <a href="#"
     id="navFabriek"
     onclick="showPanel('fabriek'); return false;">
    3D_Fabriek
  </a>
</nav>



<!-- wrapper for the existing page -->
<div id="mainContent" data-panel="shop">
  <div id="shopPanel">
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        h1 { text-align: center; }
        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .tab { margin-bottom: 20px; }
        .tab-header {
            background: #e0e0e0;
            padding: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 5px;
        }
        .tab-header:hover { background: #d0d0d0; }
        .tab-header .title {
            display: flex;
            align-items: center;
        }
        .tab-header .title i {
            margin-right: 8px; }
        .tab-content {
            padding: 10px;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 5px 5px;
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        input, select { margin-right: 10px; }
        button { padding: 5px 10px; margin-right: 10px; }
        .wide-input { width: 300px; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 100; } /* Ensure modals are on top */
        .modal-content { background: white; margin: 5% auto; padding: 20px; width: 70%; border-radius: 5px; max-height: 80vh; overflow-y: auto; }
        .modal-content input, .modal-content select { display: inline-block; margin: 5px 0; }
        .edit-items-table { width: 100%; margin-top: 10px; }
        .edit-items-table th.item-name, .edit-items-table td.item-name { width: 600px; }
        .edit-items-table th.mijn-tafel-name, .edit-items-table td.mijn-tafel-name { width: 200px; }
        .edit-items-table th.qty, .edit-items-table td.qty { width: 50px; }
        .edit-items-table th.cost, .edit-items-table td.cost { width: 130px; }
        .edit-items-table th.total, .edit-items-table td.total { width: 120px; }
        .edit-items-table th.discount, .edit-items-table td.discount { width: 100px; }
        .edit-items-table th.net-cost, .edit-items-table td.net-cost { width: 100px; }
        .edit-items-table th.price, .edit-items-table td.price { width: 100px; }
        .edit-items-table input.item-name-input { width: 98%; }
        .edit-items-table input.mijn-tafel-name-input { width: 98%; }
        .edit-items-table input.qty-input { width: 90%; }
        .edit-items-table input.cost-input { width: 90%; }
        .edit-items-table input.total-input { width: 90%; }
        .edit-items-table input.price-input { width: 90%; }
        .edit-items-table select { width: 90%; }
        .total-cost { font-weight: bold; margin-top: 10px; }
        #manageSuppliersTable, #manageCategoriesTable { width: 100%; }
        #manageSuppliersTable input, #manageCategoriesTable input { width: 90%; }
        /* Style for editable cells in manage tables */
        .editable-cell input { border: 1px solid #ccc; padding: 4px; width: calc(100% - 10px); }
        .editable-cell span { display: inline-block; min-width: 100px; padding: 4px; } /* Ensure span takes space */
        canvas { width: 100%; height: 50px; } /* Adjusted default height */
        #yearlySalesChart { height: 400px; } /* Specific height for yearly chart */
        label { display: inline-block; width: 120px; font-weight: bold; }
        .positive { color: green; }
        .negative { color: red; }
        .dashboard {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .dashboard-card {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            width: 30%;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .dashboard-card:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .dashboard-card.sales { background: #e6f3e6; }
        .dashboard-card.purchases { background: #ffe6e6; }
        .dashboard-card.inventory { background: #e6f3ff; }
        .dashboard-card h3 { margin: 0; font-size: 1.1em; }
        .dashboard-card p { margin: 5px 0 0; font-size: 1.5em; font-weight: bold; }
	#inventoryTable, #soldOutTable {
    width: 100%;
}
#inventoryTable th:nth-child(1), #soldOutTable th:nth-child(1),
#inventoryTable td:nth-child(1), #soldOutTable td:nth-child(1) {
    width: 50%;
}
#inventoryTable th:nth-child(2), #soldOutTable th:nth-child(2),
#inventoryTable td:nth-child(2), #soldOutTable td:nth-child(2) {
    width: 10%;
}
#inventoryTable th:nth-child(3), #soldOutTable th:nth-child(3),
#inventoryTable td:nth-child(3), #soldOutTable td:nth-child(3) {
    width: calc(10% - 30px) !important;
}
#inventoryTable th:nth-child(4), #soldOutTable th:nth-child(4),
#inventoryTable td:nth-child(4), #soldOutTable td:nth-child(4) {
    width: calc(10% - 30px) !important;
}
#inventoryTable th:nth-child(5), #soldOutTable th:nth-child(5),
#inventoryTable td:nth-child(5), #soldOutTable td:nth-child(5) {
    width: calc(10% - 30px) !important;
}
.sortable {
    cursor: pointer;
    position: relative;
}
#dataManagementSection button {
    font-family: Arial, sans-serif;
    padding: 10px 20px;
    margin: 10px 0;
    background: #e0e0e0;
    border: none;
    border-radius: 3px;
    cursor: pointer;
}
#dataManagementSection button:hover {
    background: #d0d0d0;
}
    </style>

    <h1>Shop Tracker</h1>

    <div class="dashboard">
        <div class="dashboard-card sales" onclick="showDashboardDetail('sales')">
            <h3>Total Sales This Month</h3>
            <p id="totalSalesMonth">€0.00</p>
        </div>
        <div class="dashboard-card purchases" onclick="showDashboardDetail('purchases')">
            <h3>Total Purchases This Month</h3>
            <p id="totalPurchasesMonth">€0.00</p>
        </div>
        <div class="dashboard-card inventory" onclick="showDashboardDetail('inventory')">
            <h3>Current Inventory Value</h3>
            <p id="inventoryValue">€0.00</p>
        </div>
    </div>

    <div class="tab">
        <div class="tab-header" onclick="toggleSection(this)">
            <span class="title"><i class="fas fa-shopping-cart"></i> Add Sale</span>
            <i class="fas fa-minus"></i>
        </div>
        <div class="tab-content active">
            <input id="saleItem" class="wide-input" placeholder="Item Name" type="text" list="inventoryItems" oninput="autoFillSaleFields('item')">
            <datalist id="inventoryItems"></datalist>
            <input id="saleMijnTafelName" class="wide-input" placeholder="Mijn Tafel Name" type="text" list="mijnTafelNames" oninput="autoFillSaleFields('mijnTafelName')">
            <datalist id="mijnTafelNames"></datalist>
            <input id="saleQty" placeholder="Quantity" type="number" min="1">
            <input id="salePrice" placeholder="Price (€)" type="number" step="0.01">
            <input id="saleTablePlace" placeholder="Table/Place" type="text">
            <input id="saleDate" type="date" max="">
            <button id="recordSaleBtn" onclick="addSale()">Record Sale</button>
        </div>
    </div>

    <div class="tab">
        <div class="tab-header" onclick="toggleSection(this)">
            <span class="title"><i class="fas fa-truck"></i> Add Purchase</span>
            <i class="fas fa-minus"></i>
        </div>
        <div class="tab-content active">
                     <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
           <div>
             <button onclick="openPurchaseModal()">Add Purchase</button>
             <button id="openAddPrintsModalBtn">Add Prints</button>
           </div>
           <div>
             <button onclick="openManageSuppliersModal()">Manage Suppliers</button>
             <button onclick="openManageCategoriesModal()">Manage Categories</button>
           </div>
         </div>

            <div id="purchaseModal" class="modal">
                <div class="modal-content">
                    <h3>Add Purchase</h3>
                    <div>
                        <label for="purchaseDateModal">Date:</label><input id="purchaseDateModal" type="date" max=""><br>
                        <label for="purchaseSupplierModal">Supplier:</label>
                        <select id="purchaseSupplierModal" class="wide-input">
                            <option value="">Select Supplier</option>
                        </select>
                        <button onclick="openSupplierModal()">New Supplier</button> <button onclick="openCategoryModal()">New Category</button><br>
                        <label for="purchaseOrderNumberModal">Order Number:</label><input id="purchaseOrderNumberModal" class="wide-input" placeholder="Order Number"><br>
                        <label for="purchaseDiscountModal">Order-level Discount:</label><input id="purchaseDiscountModal" placeholder="Order Discount (€)" type="number" step="0.01" min="0" oninput="updatePurchaseTotal()">
                    </div>
                    <table class="edit-items-table" id="purchaseItemsTable">
                        <thead>
                            <tr>
                                <th class="item-name">Item Name</th>
                                <th class="mijn-tafel-name">Mijn Tafel Name</th>
                                <th class="qty">Qty</th>
                                <th class="cost">Cost per Item (€)</th>
                                <th class="total">Cost (€)</th>
                                <th class="discount">Cost After Discount (€)</th>
                                <th class="net-cost">Item Net Cost (€)</th>
                                <th class="price">Price (€)</th>
                                <th>Category</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="purchaseItemsBody"></tbody>
                        <tfoot>
                            <tr>
                                <td colspan="5" style="text-align: right; font-weight: bold;">Total:</td>
                                <td id="purchaseDiscountTotalSum">€0.00</td>
                                <td colspan="4"></td>
                            </tr>
                        </tfoot>
                    </table>
                    <p class="total-cost">Total Cost: <span id="purchaseTotalCost">€0.00</span></p>
                    <button onclick="addPurchaseItemRow()">Add Item</button>
                    <button onclick="savePurchaseFromModal()">Save Purchase</button>
                    <button onclick="closePurchaseModal()">Cancel</button>
                </div>
            </div>
            <div id="supplierModal" class="modal">
                <div class="modal-content">
                    <h3>Add Supplier</h3>
                    <input id="newSupplierName" class="wide-input" placeholder="Supplier Name" type="text">
                    <button onclick="addSupplier()">Save Supplier</button>
                    <button onclick="closeSupplierModal()">Cancel</button>
                </div>
            </div>
            <div id="categoryModal" class="modal">
                <div class="modal-content">
                    <h3>Add Category</h3>
                    <input id="newCategoryName" class="wide-input" placeholder="Category Name" type="text">
                    <button onclick="addCategory()">Save Category</button>
                    <button onclick="closeCategoryModal()">Cancel</button>
                </div>
            </div>
            <div id="editPurchaseModal" class="modal">
                <div class="modal-content">
                    <h3>Edit Order</h3>
                    <div>
                        <label for="editDate">Date:</label><input id="editDate" type="date" max=""><br>
                        <label for="editSupplier">Supplier:</label><select id="editSupplier" class="wide-input">
                            <option value="">Select Supplier</option>
                        </select><br>
                        <label for="editOrderNumber">Order Number:</label><input id="editOrderNumber" class="wide-input" placeholder="Order Number"><br>
                        <label for="editDiscount">Order-level Discount:</label><input id="editDiscount" placeholder="Order Discount (€)" type="number" step="0.01" min="0" oninput="updateEditPurchaseTotal()">
                    </div>
                    <table class="edit-items-table" id="editItemsTable">
                        <thead>
                            <tr>
                                <th class="item-name">Item Name</th>
                                <th class="mijn-tafel-name">Mijn Tafel Name</th>
                                <th class="qty">Qty</th>
                                <th class="cost">Cost per Item (€)</th>
                                <th class="total">Cost (€)</th>
                                <th class="discount">Cost After Discount (€)</th>
                                <th class="net-cost">Item Net Cost (€)</th>
                                <th class="price">Price (€)</th>
                                <th>Category</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="editItemsBody"></tbody>
                        <tfoot>
                            <tr>
                                <td colspan="5" style="text-align: right; font-weight: bold;">Total:</td>
                                <td id="editDiscountTotalSum">€0.00</td>
                                <td colspan="4"></td>
                            </tr>
                        </tfoot>
                    </table>
                    <p class="total-cost">Total Cost: <span id="editTotalCost">€0.00</span></p>
                    <button onclick="addEditItemRow()">Add Item</button>
                    <button onclick="saveEditedPurchase()">Save Changes</button>
                    <button onclick="closeEditPurchaseModal()">Cancel</button>
                </div>
            </div>
            <div id="manageSuppliersModal" class="modal">
                <div class="modal-content">
                    <h3>Manage Suppliers</h3>
                    <input id="newSupplierInput" class="wide-input" placeholder="New Supplier Name" type="text">
                    <button onclick="addSupplierFromManage()">Add Supplier</button>
                    <table id="manageSuppliersTable">
                        <thead>
                            <tr><th>Supplier Name</th><th>Actions</th></tr>
                        </thead>
                        <tbody id="manageSuppliersBody">
                            </tbody>
                    </table>
                    <button onclick="closeManageSuppliersModal()">Close</button>
                </div>
            </div>
            <div id="manageCategoriesModal" class="modal">
                <div class="modal-content">
                    <h3>Manage Categories</h3>
                    <input id="newCategoryInput" class="wide-input" placeholder="New Category Name" type="text">
                    <button onclick="addCategoryFromManage()">Add Category</button>
                    <table id="manageCategoriesTable">
                        <thead>
                            <tr><th>Category Name</th><th>Actions</th></tr>
                        </thead>
                        <tbody id="manageCategoriesBody">
                             </tbody>
                    </table>
                    <button onclick="closeManageCategoriesModal()">Close</button>
                </div>
            </div>
        </div>
    </div>

    <div class="tab">
        <div class="tab-header" onclick="toggleSection(this)">
            <span class="title"><i class="fas fa-history"></i> Sales History</span> <i class="fas fa-minus"></i>
        </div>
        <div class="tab-content active">
            <div style="margin-bottom: 15px;">
                <button id="monthlySalesBtn" onclick="openMonthlySalesModal()">Monthly</button>
                <button id="yearlySalesBtn" onclick="openYearlySalesModal()">Yearly</button>
            </div>
            <table id="salesHistoryTable">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Item</th>
                        <th>Mijn Tafel Name</th>
                        <th>Qty</th>
                        <th>Price (€)</th>
                        <th>Total</th>
                        <th>Table/Place</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="salesHistoryBody">
                    </tbody>
                <tfoot>
                    <tr>
                        <td colspan="5" style="text-align: right; font-weight: bold;">Total:</td> <td id="salesTotalSum">€0.00</td>
                        <td colspan="2"></td>
                    </tr>
                </tfoot>
            </table>
            <div id="editSaleModal" class="modal">
                <div class="modal-content">
                    <h3>Edit Sale</h3>
                    <input type="hidden" id="editSaleIndex">
                    <div>
                        <label for="editSaleDate">Date:</label>
                        <input id="editSaleDate" type="date" max="">
                    </div>
                    <div>
                        <label for="editSaleItem">Item:</label>
                        <input id="editSaleItem" class="wide-input" placeholder="Item Name" type="text" list="inventoryItems" readonly>
                    </div>
                    <div>
                        <label for="editSaleMijnTafelName">Mijn Tafel Name:</label>
                        <input id="editSaleMijnTafelName" class="wide-input" placeholder="Mijn Tafel Name" type="text" list="mijnTafelNames" readonly>
                    </div>
                    <div>
                        <label for="editSaleQty">Quantity:</label>
                        <input id="editSaleQty" placeholder="Quantity" type="number" min="1">
                    </div>
                    <div>
                        <label for="editSalePrice">Price (€):</label>
                        <input id="editSalePrice" placeholder="Price (€)" type="number" step="0.01">
                    </div>
                    <div>
                        <label for="editSaleTablePlace">Table/Place:</label>
                        <input id="editSaleTablePlace" placeholder="Table/Place" type="text">
                    </div>
                    <button onclick="saveEditedSale()">Save Changes</button>
                    <button onclick="closeEditSaleModal()">Cancel</button>
                </div>
            </div>
            
            <div id="monthlySalesModal" class="modal">
                <div class="modal-content">
                    <h3>Monthly Sales</h3>
                    <div class="modal-header-flex">
                        <select id="monthSelector"></select>
                        <input id="newSaleItem" class="wide-input" placeholder="Item Name" type="text" list="inventoryItems" oninput="autoFillMonthlySaleFields('item')">
                        <input id="newSaleMijnTafelName" class="wide-input" placeholder="Mijn Tafel Name" type="text" list="mijnTafelNames" oninput="autoFillMonthlySaleFields('mijnTafelName')">
                        <input id="newSaleQty" placeholder="Quantity" type="number" min="1">
                        <input id="newSalePrice" placeholder="Price (€)" type="number" step="0.01">
                        <input id="newSaleTablePlace" placeholder="Table/Place" type="text">
                        <input id="newSaleDate" type="date" max="">
                        <button onclick="addSaleFromModal()">Add Sale</button>
                    </div>
                    <div class="modal-body">
                        <table id="monthlySalesTable">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Item</th>
                                    <th>Mijn Tafel Name</th>
                                    <th>Qty</th>
                                    <th>Price (€)</th>
                                    <th>Total</th>
                                    <th>Table/Place</th>
                                    <th>Actions</th>
                                </tr>
<tr class="filter-row"><th><input type="text" placeholder="Filter" data-col-index="0" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="1" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="2" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="3" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="4" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="5" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="6" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="7" style="width:90%"></th></tr>
                            </thead>
                            <tbody id="monthlySalesBody"></tbody>
                            <tfoot>
                                <tr>
                                    <td colspan="5" style="text-align: right; font-weight: bold;">Total:</td>
                                    <td id="monthlySalesTotalSum">€0.00</td>
                                    <td colspan="2"></td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                    <!-- bottom spacer -->
		<div style="height:10px; flex-shrink:0;"></div>

	<!-- button row -->
		<div id="monthlySalesBtnRow">
    		<button id="monthlySaveBtn" onclick="saveMonthlySalesChanges()" disabled>Save 		Changes</button>
    		<button onclick="closeMonthlySalesModal()">Close</button>
		</div>
</div> <!-- closes the .tab-content of Sales History -->
</div> <!-- closes the outer .tab of Sales History -->


            <div id="yearlySalesModal" class="modal">
                <div class="modal-content">
                    <h3>Yearly Sales Volume</h3>
                    <canvas id="yearlySalesChart"></canvas>
                    <button onclick="closeYearlySalesModal()">Close</button>
                </div>
            </div>
        </div>
    </div>

    <div class="tab">
        <div class="tab-header" onclick="toggleSection(this)">
            <span class="title"><i class="fas fa-shopping-bag"></i> Purchase History</span>
            <i class="fas fa-minus"></i>
        </div>
        <div class="tab-content active">
            <table id="purchaseHistoryTable">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Supplier</th>
                        <th>Order Number</th>
                        <th>Cost Before Discount (€)</th>
                        <th>Discount (€)</th>
                        <th>Total Cost (€)</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="purchaseHistoryBody">
                     </tbody>
            </table>
        </div>
    </div>

    <div class="tab">
        <div class="tab-header" onclick="toggleSection(this)">
            <span class="title"><i class="fas fa-money-bill-wave"></i> Cash Flow</span>
            <i class="fas fa-minus"></i>
        </div>
        <div class="tab-content active">
            <table id="cashFlowTable">
                 <thead>
                     <tr>
                         <th>Month</th>
                         <th>Sales (€)</th>
                         <th>Purchases (€)</th>
                         <th>Net (€)</th>
                         <th>Actions</th>
                     </tr>
                 </thead>
                 <tbody id="cashFlowBody">
                      </tbody>
            </table>
            <p>Total Cash Flow: <span id="cashFlowTotal">€0.00</span></p>
            <div id="cashFlowDetailsModal" class="modal">
                <div class="modal-content">
                    <h3>Monthly Cash Flow Details</h3>
                    <h4 id="cashFlowDetailsTitle"></h4>
                    <div style="margin-bottom: 10px;">
                        <span id="totalSalesSumLabel">Total Sales: €0.00</span> |
                        <span id="totalPurchasesSumLabel">Total Purchases: €0.00</span>
                    </div>
                    <table id="cashFlowDetailsTable">
                         <thead>
                             <tr>
                                 <th>Date</th>
                                 <th>Sales (€)</th>
                                 <th>Purchases (€)</th>
                                 <th>Net (€)</th>
                             </tr>
                         </thead>
                         <tbody id="cashFlowDetailsBody">
                              </tbody>
                    </table>
                    <button onclick="closeCashFlowDetailsModal()">Close</button>
                </div>
            </div>
        </div>
    </div>

    <div class="tab">
        <div class="tab-header" onclick="toggleSection(this)">
            <span class="title"><i class="fas fa-chart-bar"></i> Reports</span>
            <i class="fas fa-minus"></i>
        </div>
        <div class="tab-content active">
            <div style="margin-bottom: 15px;">
                <button onclick="showMarginReport()">Margin Report</button>
            </div>
            <table id="reportTable">
                 <thead>
                     <tr>
                         <th>Item</th>
                         <th>Revenue</th>
                         <th>Cost</th>
                         <th>Margin (€)</th>
                         <th>Margin (%)</th>
                     </tr>
                 </thead>
                 <tbody id="reportBody">
                      </tbody>
            </table>
        </div>
    </div>

    <div class="tab">
        <div class="tab-header" onclick="toggleSection(this)">
            <span class="title"><i class="fas fa-warehouse"></i> Inventory</span>
            <i class="fas fa-minus"></i>
        </div>
        <div class="tab-content active">
            <h3>In Stock</h3>
            <table id="inventoryTable">
                 <thead>
                     <tr>
                         <th>Item</th><th>Mijn Tafel Name</th>
                         <th>Current Qty</th>
                         <th>Purchased Qty</th>
                         <th>Sold Qty</th>
                         <th>Written-off Qty</th><th>Category</th>
                     </tr>
<tr class="filter-row"><th><input type="text" placeholder="Filter" data-col-index="0" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="1" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="2" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="3" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="4" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="5" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="6" style="width:90%"></th></tr>
                 </thead>
                 <tbody id="inventoryBody">
                      </tbody>
            </table>
            <button onclick="openWriteOffModal()">Write-off</button>
            <h3>Sold Out / Zero Stock</h3>
            <table id="soldOutTable">
               <thead>
                   <tr>
                        <th>Item</th><th>Mijn Tafel Name</th>
                        <th>Current Qty</th>
                        <th class="sortable" onclick="sortSoldOutTable('purchasedQty')">Purchased Qty <i class="fas fa-sort opacity-50 ml-1"></i></th>
                        <th class="sortable" onclick="sortSoldOutTable('soldQty')">Sold Qty <i class="fas fa-sort opacity-50 ml-1"></i></th>
                        <th class="sortable" onclick="sortSoldOutTable('writtenOffQty')">Written-off Qty <i class="fas fa-sort opacity-50 ml-1"></i></th><th>Category</th>
                    </tr>
<tr class="filter-row"><th><input type="text" placeholder="Filter" data-col-index="0" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="1" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="2" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="3" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="4" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="5" style="width:90%"></th><th><input type="text" placeholder="Filter" data-col-index="6" style="width:90%"></th></tr>
               </thead>
                <tbody id="soldOutBody">
                     </tbody>
            </table>
            <div id="writeOffModal" class="modal">
                <div class="modal-content">
                    <h3>Write-off Inventory</h3>
                    <h4>New Write-off</h4>
                    <input id="writeOffItem" class="wide-input" placeholder="Item Name" type="text" list="inventoryItems">
                    <input id="writeOffQty" placeholder="Quantity" type="number" min="1">
                    <input id="writeOffDate" type="date" max="">
                    <input id="writeOffComment" class="wide-input" placeholder="Reason for Write-off" type="text">
                    <button onclick="addWriteOff()">Record Write-off</button>
                    <h4>Write-off History</h4>
                    <table id="writeOffHistoryTable">
                         <thead>
                             <tr>
                                 <th>Date</th>
                                 <th>Item</th>
                                 <th>Qty</th>
                                 <th>Cost (€)</th>
                                 <th>Comment</th>
                                 <th>Action</th>
                             </tr>
                         </thead>
                         <tbody id="writeOffHistoryBody">
                              </tbody>
                    </table>
                    <button onclick="closeWriteOffModal()">Close</button>
                </div>
            </div>
        </div>
    </div>

<!-- Rent Section -->
<div class="tab">
    <div class="tab-header" onclick="toggleSection(this)">
        <span class="title"><i class="fas fa-house-user"></i> Rent</span>
        <i class="fas fa-minus"></i>
    </div>
    <div class="tab-content active">
        <!-- Add Rental Payment Button -->
        <button onclick="openAddRentalPaymentModal()">Add Rental Payment</button>
        <table id="rentalPaymentTable" border="1" style="width: 100%; margin-top: 20px;">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Table/Place</th>
                    <th>Payment Date</th>
                    <th>Rental Period</th>
                    <th>Duration</th>
                    <th>Amount</th>
                    <th>Comments</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                <!-- Table rows will be dynamically added here -->
            </tbody>
        </table>
    </div>
</div>

<!-- Rental Payment Modal -->
<div id="rentalPaymentModal" class="modal">
    <div class="modal-content">
        <h3>Add Rental Payment</h3>
        <div>
            <label for="rentalTablePlace">Table/Place:</label>
            <input id="rentalTablePlace" type="text" placeholder="Enter Table/Place">
        </div>
        <div>
            <label for="rentalDate">Payment Date:</label>
            <input id="rentalDate" type="date" max="" onchange="setDateLimits()">
        </div>
        <div>
            <label for="rentalPeriodStart">Rental Period Start:</label>
            <input id="rentalPeriodStart" type="date" onchange="updateRentalPeriod()">
        </div>
        <div>
            <label for="rentalPeriodEnd">Rental Period End:</label>
            <input id="rentalPeriodEnd" type="date" onchange="updateRentalPeriod()">
        </div>
        <div>
            <label for="rentalPeriod">Rental Period:</label>
            <input id="rentalPeriod" type="text" readonly placeholder="Selected Rental Period">
        </div>
        <div>
            <label for="rentalDuration">Duration (working days):</label>
            <input id="rentalDuration" type="text" readonly placeholder="Calculated Duration">
        </div>
        <div>
            <label for="rentalAmount">Amount (€):</label>
            <input id="rentalAmount" type="number" step="0.01" placeholder="Amount (€)">
        </div>
        <div>
            <label for="rentalComments">Comments:</label>
            <input id="rentalComments" type="text" placeholder="Optional comments">
        </div>
        <button onclick="saveRentalPayment()">Save Payment</button>
        <button onclick="closeRentalPaymentModal()">Cancel</button>
    </div>
</div>

<!-- Edit Rental Payment Modal -->
<div id="editRentalPaymentModal" class="modal">
    <div class="modal-content">
        <h3>Edit Rental Payment</h3>
        <input type="hidden" id="editRentalPaymentIndex">
        <div>
            <label for="editRentalTablePlace">Table/Place:</label>
            <input id="editRentalTablePlace" type="text" placeholder="Enter Table/Place">
        </div>
        <div>
            <label for="editRentalDate">Payment Date:</label>
            <input id="editRentalDate" type="date" max="" onchange="setDateLimits()">
        </div>
        <div>
            <label for="editRentalPeriodStart">Rental Period Start:</label>
            <input id="editRentalPeriodStart" type="date" onchange="updateEditRentalPeriod()">
        </div>
        <div>
            <label for="editRentalPeriodEnd">Rental Period End:</label>
            <input id="editRentalPeriodEnd" type="date" onchange="updateEditRentalPeriod()">
        </div>
        <div>
            <label for="editRentalPeriod">Rental Period:</label>
            <input id="editRentalPeriod" type="text" readonly placeholder="Selected Rental Period">
        </div>
        <div>
            <label for="editRentalDuration">Duration (working days):</label>
            <input id="editRentalDuration" type="text" readonly placeholder="Calculated Duration">
        </div>
        <div>
            <label for="editRentalAmount">Amount (€):</label>
            <input id="editRentalAmount" type="number" step="0.01" placeholder="Amount (€)">
        </div>
        <div>
            <label for="editRentalComments">Comments:</label>
            <input id="editRentalComments" type="text" placeholder="Optional comments">
        </div>
        <div class="button-group">
    <button onclick="saveEditedRentalPayment()">Save Changes</button>
    <button onclick="closeEditRentalPaymentModal()">Cancel</button>
</div>
    </div>
</div>

<!-- Item Details Modal -->
<div id="itemDetailsModal" class="modal">
    <div class="modal-content">
      
      <!-- 1) Header (two-column grid for alignment) -->
        <div id="itemDetailsHeader"
        style="
        margin-bottom:1em;
        display: grid;
        grid-template-columns: max-content auto;
        column-gap: 1em;
        row-gap: 0.25em;
        align-items: baseline;
        ">
        <div><strong>Item Name:</strong></div>
        <div><span id="itemDetailsName"></span></div>

        <div><strong>Mijn Tafel Name:</strong></div>
        <div><span id="itemDetailsMijn"></span></div>

        <div><strong>Current Qty:</strong></div>
        <div><span id="itemDetailsQty"></span></div>
        </div>

  
      <!-- 2) Purchases -->
      <h4>Purchase History</h4>
      <table id="itemDetailsPurchasesTable">
        <thead>
          <tr>
            <th>Date</th><th>Supplier</th><th>Order Number</th>
            <th>Qty</th><th>Net Cost (€)</th><th>Cost After Discount (€)</th>
          </tr>
        </thead>
        <tbody></tbody>
        <tfoot>
          <tr>
            <td colspan="5" style="text-align:right;font-weight:bold">Subtotal:</td>
            <td id="itemDetailsPurchaseSubtotal">€0.00</td>
          </tr>
        </tfoot>
      </table>
  
      <!-- 3) Sales -->
      <h4>Sales History</h4>
      <table id="itemDetailsSalesTable">
        <thead>
          <tr>
            <th>Date</th><th>Price (€)</th><th>Qty</th>
            <th>Total (€)</th><th>Gross Margin (€)</th><th>Table/Place</th>
          </tr>
        </thead>
        <tbody></tbody>
        <tfoot>
          <tr>
                    <!-- now colspan=1 for the label, then an empty cell under Price -->
           <td></td>
           <td colspan="1" style="text-align:right;font-weight:bold">Totals:</td>
           <td id="itemDetailsSalesTotalQty">0</td>
            <td id="itemDetailsSalesTotal">€0.00</td>
            <td id="itemDetailsGrossMarginTotal">€0.00</td>
            <td></td>
          </tr>
        </tfoot>
      </table>
  
      <!-- 4) Cash Flow & Close -->
      <div style="margin-top:1em; font-weight:bold;">
        Item’s Cash Flow: <span id="itemDetailsCashFlow">€0.00</span>
      </div>

      <!-- Close button -->
    <div style="margin-top:1em; text-align:left;">
        <button onclick="closeModal('itemDetailsModal')">Close</button>
      </div>
  
    </div>
  </div>
  

<!-- Data Management Section -->

    <div class="tab" id="dataManagementSection">
        <div class="tab-header" onclick="toggleSection(this)">
            <span class="title"><i class="fas fa-cog"></i> Data Management</span>
            <i class="fas fa-minus"></i>
        </div>
        <div class="tab-content active">
            <button onclick="exportSalesData()">Export Sales Data</button>
            <button onclick="document.getElementById('importSalesFile').click()">Import Sales Data</button>
            <input type="file" id="importSalesFile" accept=".xls,.xlsx" style="display: none;" onchange="importSalesData(this.files[0])">
            <button onclick="exportPurchasesData()">Export Purchases Data</button>

        </div>
    </div>
<script>
// --- Global Variables and Constants ---
const euro = new Intl.NumberFormat('nl-NL', { style: 'currency', currency: 'EUR' });

/** Round *up* to the nearest €-cent without losing the real value */
function ceilCent(value) {
    //  multiply → ceil   → divide so  0.0012 → 0.01   and  1.231 → 1.24
    return Math.ceil(value * 100) / 100;
}

/** Format a number for the UI while *not* changing the underlying number */
function formatMoneyUp(value){
    return euro.format( ceilCent(value) );
}

function getTodayStrLocal() {
    const d = new Date();
    d.setHours(0, 0, 0, 0);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0'); // Months are 0-indexed
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

let inventory = {};
let soldOutItems = {};
let transactions = [];
let writeOffs = [];
let suppliers = [];
let categories = [];
let soldOutSortColumn = null;
let soldOutSortDirection = 'asc';
let purchases = [];
let rentalPayments = [];



/* Remembers the last date typed in the Monthly-Sales “Add Sale” strip */
let lastMonthlySaleDate =
    localStorage.getItem('lastMonthlySaleDate')   // persisted from a previous visit
let lastMainSaleDate =
    localStorage.getItem('lastMainSaleDate')   // persisted from earlier visits
/* Flag that tells us whether anything was edited in the Monthly-Sales table */
let monthlySalesDirty = false;

// --- Data Handling (Load, Save, Reset) ---
function loadData() {
  return fetch("/data")
    .then(response => response.json())
    .then(data => {
      console.log("✅ Loaded from backend:", data);
      console.log("🧪 Type of data.transactions:", typeof data.transactions);

      try {
  inventory = typeof data.inventory === 'object' ? data.inventory : JSON.parse(data.inventory);
} catch {
  console.warn("⚠️ Failed to parse inventory from backend. Defaulting to empty.");
  inventory = {};
}

      soldOutItems = data.soldOutItems || {};
      if (!soldOutItems || typeof soldOutItems !== 'object') soldOutItems = {};

      transactions = Array.isArray(data.transactions) ? data.transactions.filter(t =>
        t && typeof t === 'object' &&
        ['sale', 'purchase'].includes(t.type) &&
        t.item &&
        typeof t.qty === 'number' && t.qty > 0 &&
        typeof t.total === 'number' && t.total >= 0 &&
        t.date && /^\d{2}\/\d{2}\/\d{4}$/.test(t.date)
      ) : [];

      purchases = transactions.filter(t => t.type === "purchase");

      writeOffs = Array.isArray(data.writeOffs) ? data.writeOffs.filter(w =>
        w && typeof w === 'object' &&
        w.item &&
        typeof w.qty === 'number' && w.qty > 0 &&
        typeof w.cost === 'number' && w.cost >= 0 &&
        w.date && /^\d{2}\/\d{2}\/\d{4}$/.test(w.date)
      ) : [];

      suppliers = Array.isArray(data.suppliers) ? data.suppliers.filter(s => typeof s === 'string' && s.trim()) : [];

      categories = Array.isArray(data.categories) ? data.categories.filter(c => typeof c === 'string' && c.trim()) : [];

      window.rentalPayments = Array.isArray(data.rentalPayments) ? data.rentalPayments : [];

      console.log('Data loaded:', {
        inventory,
        soldOutItems,
        transactions,
        writeOffs,
        suppliers,
        categories,
        rentalPayments: window.rentalPayments
      });

      recalculateInventory();
    })
    .catch(e => {
      console.error("❌ Failed to load from backend:", e);
      alert("Error loading data from backend. Using empty/default values.");

      inventory = {};
      soldOutItems = {};
      transactions = [];
      writeOffs = [];
      suppliers = [];
      categories = [];
      window.rentalPayments = [];

      recalculateInventory();
    });
}



function saveData() {
  try {
    const dataToSave = {
      inventory,
      transactions,
      writeOffs,
      suppliers,
      categories,
      soldOutItems,
      rentalPayments: window.rentalPayments || []
    };

    console.log('Saving dataToSave:', dataToSave); // ✅ Confirm it’s populated

    fetch('/save', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(dataToSave)
    })
      .then(response => response.json())
      .then(result => {
        if (result.status === 'success') {
          console.log('✅ Data saved to backend');
        } else {
          console.error('❌ Failed to save data:', result.message);
          alert('Failed to save changes to backend.');
        }
      })
      .catch(error => {
        console.error('❌ Error saving data:', error);
        alert('Failed to save changes to backend.');
      });
  } catch (e) {
    console.error('Error saving data:', e);
    alert('Failed to save data. Check browser storage permissions and quota.');
  }
}




// --- UI Interaction (Toggles, Modals) ---
function toggleSection(header) {
    try {
        const content = header.nextElementSibling;
        const icon = header.querySelector('i:last-child'); // More specific selector
        if (content && icon) {
            const isActive = content.classList.toggle('active');
            icon.classList.toggle('fa-minus', isActive); // Set fa-minus if active
            icon.classList.toggle('fa-plus', !isActive); // Set fa-plus if not active
        } else {
            console.warn('Toggle section failed: missing content or icon element for header:', header);
        }
    } catch (e) {
        console.error('Error in toggleSection:', e);
    }
}

function closeModal(modalId) {
    try {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = 'none';
        } else {
            console.warn(`Modal with id "${modalId}" not found for closing.`);
        }
    } catch (e) {
        console.error(`Error closing modal ${modalId}:`, e);
    }
}

// Convenience functions for closing specific modals
function closePurchaseModal() { closeModal('purchaseModal'); }
function closeEditPurchaseModal() { closeModal('editPurchaseModal'); }
function closeSupplierModal() { closeModal('supplierModal'); }
function closeCategoryModal() { closeModal('categoryModal'); }
function closeManageSuppliersModal() { closeModal('manageSuppliersModal'); }
function closeManageCategoriesModal() { closeModal('manageCategoriesModal'); }
function closeEditSaleModal() { closeModal('editSaleModal'); }

function closeMonthlySalesModal() {
    monthlySalesDirty = false;     // reset the flag
    toggleMonthlySaveBtn(false);   // grey the button
    closeModal('monthlySalesModal');
}

function closeYearlySalesModal() { closeModal('yearlySalesModal'); }
function closeCashFlowDetailsModal() { closeModal('cashFlowDetailsModal'); }
function closeWriteOffModal() { closeModal('writeOffModal'); }

// --- Date Handling ---
function parseEuropeanDate(dateStr) {
    try {
        if (!dateStr || typeof dateStr !== 'string') {
            throw new Error('Invalid input (must be a string)');
        }

        // Handle YYYY-MM-DD
        if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
            const [year, month, day] = dateStr.split('-').map(Number);
            const date = new Date(year, month - 1, day);
            if (isNaN(date.getTime()) || date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
                throw new Error('Invalid date (YYYY-MM-DD)');
            }
            return date;
        }

        // Handle DD/MM/YYYY
        if (/^\d{2}\/\d{2}\/\d{4}$/.test(dateStr)) {
            const [day, month, year] = dateStr.split('/').map(Number);
            const date = new Date(year, month - 1, day);
            if (isNaN(date.getTime()) || date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
                throw new Error('Invalid date (DD/MM/YYYY)');
            }
            return date;
        }

        // Handle MM/DD/YY
        if (/^\d{1,2}\/\d{1,2}\/\d{2}$/.test(dateStr)) {
            const [month, day, year] = dateStr.split('/').map(Number);
            const fullYear = year < 50 ? 2000 + year : 1900 + year;
            const date = new Date(fullYear, month - 1, day);
            if (isNaN(date.getTime()) || date.getFullYear() !== fullYear || date.getMonth() !== month - 1 || date.getDate() !== day) {
                throw new Error('Invalid date (MM/DD/YY)');
            }
            return date;
        }

        throw new Error('Unrecognized date format');
    } catch (e) {
        console.error('parseEuropeanDate error:', dateStr, e.message);
        return new Date('Invalid Date');
    }
}

function formatEuropeanDate(date) {
    try {
        // Check if input is a valid Date object
        if (!(date instanceof Date) || isNaN(date.getTime())) {
            throw new Error('Invalid date object provided');
        }
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
        const year = date.getFullYear();
        return `${day}/${month}/${year}`;
    } catch (e) {
        console.error('Error formatting date:', date, e);
        // Fallback to today's date in the correct format
        const today = new Date(); today.setHours(0,0,0,0);
        const day = String(today.getDate()).padStart(2, '0');
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const year = today.getFullYear();
        return `${day}/${month}/${year}`;
    }
}

function formatDateForInput(europeanDate) {
    try {
        if (!europeanDate || typeof europeanDate !== 'string' || !/^\d{2}\/\d{2}\/\d{4}$/.test(europeanDate)) {
            // console.warn('Invalid European date format for input:', europeanDate);
            return ''; // Return empty for invalid format
        }
        const date = parseEuropeanDate(europeanDate);
        if (isNaN(date.getTime())) { // Check if parsing failed
            // console.warn('Failed to parse European date for input:', europeanDate);
            return '';
        }
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        return `${year}-${month}-${day}`; // Return YYYY-MM-DD
    } catch (e) {
        console.error('Error in formatDateForInput:', europeanDate, e);
        return ''; // Return empty string on error
    }
}

function setDateLimits() {
    try {
        const todayDate = new Date();
        todayDate.setHours(0, 0, 0, 0);
        const today = getTodayStrLocal();
        console.log(`setDateLimits: Setting max date to ${today} 

// Get the category for an item based on latest purchase
function getCategoryForItem(item) {
    const tx = transactions
        .filter(t => t.type === 'purchase' && t.item === item && t.category)
        .sort((a, b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date))[0];
    return tx ? tx.category : '';
}
(${todayDate.toLocaleString('en-GB', { timeZone: 'Europe/Amsterdam' })})`);
        const dateInputs = document.querySelectorAll('input[type="date"]');
        if (dateInputs.length === 0) {
            console.warn('setDateLimits: No date inputs found in DOM');
        }
        dateInputs.forEach(input => {
            if (input) {
                input.max = today;
                console.log(`setDateLimits: Set #${input.id || 'unnamed'} max="${input.max}"`);
                // Force browser to recognize max
                input.setAttribute('max', today);
                // Log actual DOM value
                const domMax = input.getAttribute('max');
                if (domMax !== today) {
                    console.warn(`setDateLimits: DOM max="${domMax}" differs for #${input.id || 'unnamed'}, reapplying`);
                    input.setAttribute('max', today);
                }
            }
        });
        console.log(`setDateLimits: Processed ${dateInputs.length} date inputs`);
    } catch (e) {
        console.error('Error in setDateLimits:', e);
    }
}
// --- Inventory Calculation and Quantity Getters ---
function getSoldQuantity(item) {
    try {
        if (!item) return 0;
        return transactions
            .filter(t => t.type === 'sale' && t.item === item)
            .reduce((sum, sale) => sum + (Number(sale.qty) || 0), 0);
    } catch (e) {
        console.error(`Error in getSoldQuantity for item "${item}":`, e);
        return 0;
    }
}

function getPurchasedQuantity(item) {
    try {
        if (!item) return 0;
        return transactions
            .filter(t => t.type === 'purchase' && t.item === item)
            .reduce((sum, purchase) => sum + (Number(purchase.qty) || 0), 0);
    } catch (e) {
        console.error(`Error in getPurchasedQuantity for item "${item}":`, e);
        return 0;
    }
}

function getWrittenOffQuantity(item) {
    try {
        if (!item) return 0;
        return writeOffs
            .filter(w => w.item === item)
            .reduce((sum, writeOff) => sum + (Number(writeOff.qty) || 0), 0);
    } catch (e) {
        console.error(`Error in getWrittenOffQuantity for item "${item}":`, e);
        return 0;
    }
}

function getInventoryFromTransactions(transactions) {
    const inventory = {};
    transactions.forEach(tx => {
        if (!inventory[tx.item]) inventory[tx.item] = 0;
        if (tx.type === 'purchase') inventory[tx.item] += tx.qty;
        if (tx.type === 'sale') inventory[tx.item] -= tx.qty;
    });
    return inventory;
}

function recalculateInventory() {
    try {
        const newInventory = {};
        const newSoldOutItems = {};

        // Create a set of all unique item names from transactions and write-offs
        const allItems = new Set();
        transactions.forEach(t => { if (t.item) allItems.add(t.item); });
        writeOffs.forEach(w => { if (w.item) allItems.add(w.item); });
        // Also consider items previously in inventory or sold out lists
        Object.keys(inventory).forEach(item => allItems.add(item));
        Object.keys(soldOutItems).forEach(item => allItems.add(item));


        // Calculate net quantity for each item
        allItems.forEach(item => {
            if (!item) return; // Skip if item name is invalid

            const purchased = getPurchasedQuantity(item);
            const sold = getSoldQuantity(item);
            const writtenOff = getWrittenOffQuantity(item);
            const currentQty = purchased - sold - writtenOff;

            if (currentQty > 0) {
                newInventory[item] = currentQty;
            } else {
                // Only add to soldOut if it was ever purchased
                if (purchased > 0) {
                    newSoldOutItems[item] = 0; // Mark as sold out (or net zero/negative)
                }
            }
        });

        // Update the global state
        inventory = newInventory;
        soldOutItems = newSoldOutItems;

        saveData(); // Save the recalculated state
        updateInventoryTable(); // Update the UI tables
        updateSaleItemList(); // Update datalists
        updateMijnTafelNameList();
        checkSaleItemValidity(); // Re-check button state

    } catch (e) {
        console.error('Error in recalculateInventory:', e);
        // Attempt to update tables even on error, might show partial data
        updateInventoryTable();
    }
}

// --- Dashboard ---
function updateDashboard() {
    try {
        const currentDate = new Date();
        const currentYear = currentDate.getFullYear();
        const currentMonth = currentDate.getMonth(); // 0-indexed

        let salesMonth = 0;
        let purchasesMonth = 0;

        transactions.forEach(t => {
            const transactionDate = parseEuropeanDate(t.date);
            // Ensure date is valid before comparing
            if (!isNaN(transactionDate.getTime())) {
                if (transactionDate.getFullYear() === currentYear && transactionDate.getMonth() === currentMonth) {
                    if (t.type === 'sale') {
                        salesMonth += t.total || 0;
                    } else if (t.type === 'purchase') {
                        purchasesMonth += t.total || 0;
                    }
                }
            }
        });


        let inventoryValue = 0;
        for (const item in inventory) {
             // Find the latest purchase price for this item
             const latestPurchase = transactions
                 .filter(t => t.type === 'purchase' && t.item === item && typeof t.price === 'number')
                 .sort((a, b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date))[0]; // Sort descending by date

             const itemPrice = latestPurchase ? latestPurchase.price : 0; // Use latest purchase price, or 0 if none found
             inventoryValue += (inventory[item] || 0) * itemPrice;
        }


        const salesElement = document.getElementById('totalSalesMonth');
        const purchasesElement = document.getElementById('totalPurchasesMonth');
        const inventoryElement = document.getElementById('inventoryValue');

        if (salesElement) salesElement.textContent = euro.format(salesMonth);
        else console.warn('Dashboard element #totalSalesMonth missing');

        if (purchasesElement) purchasesElement.textContent = euro.format(purchasesMonth);
        else console.warn('Dashboard element #totalPurchasesMonth missing');

        if (inventoryElement) inventoryElement.textContent = euro.format(inventoryValue);
        else console.warn('Dashboard element #inventoryValue missing');

        console.log('Dashboard updated:', { salesMonth, purchasesMonth, inventoryValue });
    } catch (e) {
        console.error('Error in updateDashboard:', e);
    }
}

function showDashboardDetail(type) {
    try {
        const salesElement = document.getElementById('totalSalesMonth');
        const purchasesElement = document.getElementById('totalPurchasesMonth');
        const inventoryElement = document.getElementById('inventoryValue');

        let message = 'Error: Data unavailable';
        if (type === 'sales' && salesElement) {
            message = `Total Sales This Month: ${salesElement.textContent}`;
        } else if (type === 'purchases' && purchasesElement) {
            message = `Total Purchases This Month: ${purchasesElement.textContent}`;
        } else if (type === 'inventory' && inventoryElement) {
            message = `Current Inventory Value: ${inventoryElement.textContent}`;
        }
        alert(message);
    } catch (e) {
        console.error('Error in showDashboardDetail:', e);
        alert('Could not retrieve dashboard details.');
    }
}

// --- Sales Handling ---
function addSale() {
    try {
        const itemInput = document.getElementById('saleItem');
        const mijnTafelNameInput = document.getElementById('saleMijnTafelName');
        const qtyInput = document.getElementById('saleQty');
        const priceInput = document.getElementById('salePrice');
        const tablePlaceInput = document.getElementById('saleTablePlace');
        const dateInput = document.getElementById('saleDate');

        const item = itemInput.value.trim();
        const mijnTafelName = mijnTafelNameInput.value.trim();
        const qty = parseInt(qtyInput.value);
        const price = parseFloat(priceInput.value);
        const tablePlace = tablePlaceInput.value.trim();
        const dateValue = dateInput.value; // YYYY-MM-DD

        if (!item || isNaN(qty) || qty <= 0 || isNaN(price) || price < 0 || !dateValue) { // Price can be 0
            alert('Please fill Item Name, Quantity (>0), Price (>=0), and Date correctly.');
            return;
        }

        // Check inventory availability
        if (!inventory[item] || inventory[item] < qty) {
            alert(`Not enough inventory for "${item}". Available: ${inventory[item] || 0}`);
            return;
        }

        const date = new Date(dateValue); // Parse YYYY-MM-DD
        if (isNaN(date.getTime())) {
            alert('Invalid date selected.');
            return;
        }
        const formattedDate = formatEuropeanDate(date); // Convert to DD/MM/YYYY for storage

        // Check if date is in the future (comparing start of selected day vs start of today in local time)
        const today = new Date(); today.setHours(0,0,0,0);
        today.setHours(0, 0, 0, 0); // Set to start of today (local time, e.g., CET)
        date.setHours(0, 0, 0, 0);
	if (date.getTime() > today.getTime()) { // today allowed
            alert("Sale date cannot be in the future.");
            return;
        }

        const total = qty * price;
        transactions.push({
            type: 'sale',
            item,
            mijnTafelName: mijnTafelName || '', // Store empty string if blank
            qty,
            price,
            total,
            tablePlace: tablePlace || '', // Store empty string if blank
            date: formattedDate
        });

        recalculateInventory(); // Updates inventory, soldOutItems, calls saveData, updates tables/lists
        updateSalesHistoryTable(); // Refresh main sales history table
        updateCashFlowTable(); // Update cash flow
        updateDashboard(); // Update dashboard figures

        // Clear input fields
        itemInput.value = '';
        mijnTafelNameInput.value = '';
        qtyInput.value = '';
        priceInput.value = '';
        tablePlaceInput.value = '';
        /* Remember the date we just used */
	lastMainSaleDate = dateValue;                   // YYYY-MM-DD
	localStorage.setItem('lastMainSaleDate', dateValue);

	/* Pre-fill the box for the next entry */
	dateInput.value = lastMainSaleDate;
        checkSaleItemValidity(); // Disable button again

        console.log('Sale added:', { item, mijnTafelName, qty, price, total, tablePlace, date: formattedDate });
    } catch (e) {
        console.error('Error in addSale:', e);
        alert('An error occurred while adding the sale.');
    }
}


function updateSalesHistoryTable() {
    const tableBody = document.getElementById('salesHistoryBody');
    const totalSumElem = document.getElementById('salesTotalSum');
    if (!tableBody || !totalSumElem) return;
    tableBody.innerHTML = '';
    let totalSum = 0;
    const today = getTodayStrLocal(); // YYYY-MM-DD
    const sales = transactions
        .filter(t => t.type === 'sale' && formatDateForInput(t.date) === today)
        .sort((a, b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date));
    if (sales.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="8" style="text-align:center;">No sales recorded today</td></tr>';
    } else {
        sales.forEach(sale => {
            const idx = transactions.findIndex(t => t === sale);
            totalSum += sale.total || 0;
            const row = tableBody.insertRow();
            row.innerHTML = `
                <td>${sale.date}</td>
                <td>${sale.item}</td>
                <td>${sale.mijnTafelName || ''}</td>
                <td>${sale.qty}</td>
                <td>${euro.format(sale.price || 0)}</td>
                <td>${euro.format(sale.total || 0)}</td>
                <td>${sale.tablePlace || ''}</td>
                <td>
                    <button onclick="openEditSaleModal(${idx})">Edit</button>
                    <button onclick="deleteSale(${idx})">Delete</button>
                </td>`;
        });
    }
    totalSumElem.textContent = euro.format(totalSum);
}



function openEditSaleModal(originalIndex) {
    try {
        // Validate index
        if (originalIndex < 0 || originalIndex >= transactions.length) {
            alert('Error: Invalid sale index.');
            console.error("Invalid index passed to openEditSaleModal:", originalIndex);
            return;
        }

        const sale = transactions[originalIndex];
        if (!sale || sale.type !== 'sale') {
            alert('Error: Transaction is not a sale or not found.');
            console.error("Transaction at index is not a sale or not found:", originalIndex, sale);
            return;
        }

        const modal = document.getElementById('editSaleModal');
        if (!modal) {
            console.warn('Edit sale modal element not found');
            return;
        }

        document.getElementById('editSaleIndex').value = originalIndex; // Store the original index
        document.getElementById('editSaleDate').value = formatDateForInput(sale.date); // Convert DD/MM/YYYY to YYYY-MM-DD
        document.getElementById('editSaleItem').value = sale.item || '';
        document.getElementById('editSaleMijnTafelName').value = sale.mijnTafelName || '';
        document.getElementById('editSaleQty').value = sale.qty || 1;
        document.getElementById('editSalePrice').value = sale.price || 0;
        document.getElementById('editSaleTablePlace').value = sale.tablePlace || '';

        setDateLimits(); // Ensure max date is set for the modal input
        modal.style.display = 'block';
        console.log('Edit sale modal opened for original index:', originalIndex);
    } catch (e) {
        console.error('Error in openEditSaleModal:', e);
        alert('Could not open edit sale window.');
    }
}

function saveEditedSale() {
    try {
        const index = parseInt(document.getElementById('editSaleIndex').value);
        const dateValue = document.getElementById('editSaleDate').value; // YYYY-MM-DD
        const qty = parseInt(document.getElementById('editSaleQty').value);
        const price = parseFloat(document.getElementById('editSalePrice').value);
        const tablePlace = document.getElementById('editSaleTablePlace').value.trim();

        if (isNaN(index) || index < 0 || index >= transactions.length) {
            alert('Error: Invalid sale reference.');
            return;
        }

        if (!dateValue || isNaN(qty) || qty <= 0 || isNaN(price) || price < 0) { // Price can be 0
            alert('Please fill Date, Quantity (>0), and Price (>=0) correctly.');
            return;
        }

        const sale = transactions[index];
        if (!sale || sale.type !== 'sale') {
            alert('Error: Original sale record not found.');
            return;
        }

        const date = new Date(dateValue);
        if (isNaN(date.getTime())) {
            alert('Invalid date selected.');
            return;
        }
        const formattedDate = formatEuropeanDate(date); // Convert to DD/MM/YYYY

        // Check if date is in the future (comparing start of selected day vs start of today in local time)
        const today = new Date(); today.setHours(0,0,0,0);
        today.setHours(0, 0, 0, 0); // Set to start of today (local time, e.g., CET)
	date.setHours(0, 0, 0, 0);        
	if (date.getTime() > today.getTime()) { // today allowed
            alert("Sale date cannot be in the future.");
            return;
        }

        const oldQty = sale.qty;
        // Calculate available inventory *before* this specific sale was made
        const availableBeforeThisSale = (inventory[sale.item] || 0) + oldQty;

        if (availableBeforeThisSale < qty) {
             alert(`Not enough inventory to increase sale quantity for "${sale.item}". Available (excluding original sale): ${availableBeforeThisSale - oldQty}. Required: ${qty}`);
             return;
        }

        // Update the transaction
        sale.date = formattedDate;
        sale.qty = qty;
        sale.price = price;
        sale.total = qty * price;
        sale.tablePlace = tablePlace || '';

        recalculateInventory(); // Recalculate based on the change, this calls saveData
        updateSalesHistoryTable(); // Refresh the main history table
        updateMonthlySalesTable(); // Refresh the modal table if open
        updateCashFlowTable();
        updateDashboard();
        closeModal('editSaleModal');

        console.log('Sale edited:', { index, date: formattedDate, qty, price, tablePlace });
    } catch (e) {
        console.error('Error in saveEditedSale:', e);
        alert('An error occurred while saving the edited sale.');
    }
}

function deleteSale(originalIndex) {
    try {
        console.log("Attempting to delete sale at original index:", originalIndex);
        // Validate index
        if (originalIndex < 0 || originalIndex >= transactions.length) {
             console.error("Invalid index provided to deleteSale:", originalIndex);
             alert("Error: Cannot delete sale. Invalid index.");
             return;
        }

        const sale = transactions[originalIndex];

        // Check if the transaction at the index is actually a sale
        if (!sale || sale.type !== 'sale') {
            console.error("Transaction at index is not a sale or not found:", originalIndex, sale);
            alert('Error: Sale not found at the specified index.');
            updateSalesHistoryTable(); // Refresh UI just in case
            updateMonthlySalesTable();
            return;
        }

        if (!confirm(`Are you sure you want to delete this sale?\n\nDate: ${sale.date}\nItem: ${sale.item}\nQty: ${sale.qty}`)) return;

        console.log("Deleting sale:", sale);
        transactions.splice(originalIndex, 1); // Remove the sale from the main array
        console.log("Transactions after splice:", transactions.length);

        recalculateInventory(); // Recalculate inventory, this calls saveData
        console.log("Inventory recalculated and data saved.");

        // Update relevant UI components
        updateSalesHistoryTable();
        updateMonthlySalesTable(); // Crucial to refresh the modal if it's open
        updateCashFlowTable();
        updateDashboard();

        console.log('Sale deleted successfully at original index:', originalIndex);
    } catch (e) {
        console.error('Error in deleteSale:', e);
        alert('An error occurred while deleting the sale.');
        // Attempt to refresh UI even on error
        updateSalesHistoryTable();
        updateMonthlySalesTable();
    }
}

// --- Auto-fill Functions ---

function autoFillSaleFields(triggerField) {
    try {
        const itemInput = document.getElementById('saleItem');
        const mijnTafelNameInput = document.getElementById('saleMijnTafelName');
        const priceInput = document.getElementById('salePrice');
        const itemName = itemInput.value.trim();
        const mijnTafelName = mijnTafelNameInput.value.trim();
        let relevantPurchases = [];
        if (triggerField === 'item' && itemName) {
            relevantPurchases = transactions.filter(t => t.type==='purchase' && t.item===itemName && (!mijnTafelName || t.mijnTafelName===mijnTafelName));
        } else if (triggerField === 'mijnTafelName' && mijnTafelName) {
            relevantPurchases = transactions.filter(t => t.type==='purchase' && t.mijnTafelName===mijnTafelName && (!itemName || t.item===itemName));
        }
        relevantPurchases.sort((a, b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date));
        if (relevantPurchases.length > 0) {
            const latest = relevantPurchases[0];
            if (typeof latest.price === 'number') {
                priceInput.value = latest.price;
            }
            if (triggerField === 'item' && latest.mijnTafelName) {
                mijnTafelNameInput.value = latest.mijnTafelName;
            }
            if (triggerField === 'mijnTafelName' && latest.item) {
                itemInput.value = latest.item;
            }
        }
        checkSaleItemValidity(); // Re-check button state
    } catch (e) {
        console.error('Error in autoFillSaleFields:', e);
    }
}
function autoFillMonthlySaleFields(triggerField) {
    try {
        const itemInput = document.getElementById('newSaleItem');
        const mijnTafelNameInput = document.getElementById('newSaleMijnTafelName');
        const priceInput = document.getElementById('newSalePrice');
        const itemName = itemInput.value.trim();
        const mijnTafelName = mijnTafelNameInput.value.trim();
        let relevantPurchases = [];
        if (triggerField === 'item' && itemName) {
            relevantPurchases = transactions.filter(t => t.type==='purchase' && t.item===itemName && (!mijnTafelName || t.mijnTafelName===mijnTafelName));
        } else if (triggerField === 'mijnTafelName' && mijnTafelName) {
            relevantPurchases = transactions.filter(t => t.type==='purchase' && t.mijnTafelName===mijnTafelName && (!itemName || t.item===itemName));
        }
        relevantPurchases.sort((a, b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date));
        if (relevantPurchases.length > 0) {
            const latest = relevantPurchases[0];
            if (typeof latest.price === 'number') {
                priceInput.value = latest.price;
            }
            if (triggerField === 'item' && latest.mijnTafelName) {
                mijnTafelNameInput.value = latest.mijnTafelName;
            } else if (triggerField === 'mijnTafelName' && latest.item) {
                itemInput.value = latest.item;
            }
        }
    } catch (e) {
        console.error('Error in autoFillMonthlySaleFields:', e);
    }
}


// NEW: Autofill for Purchase Modal Rows
function autoFillPurchaseFields(inputElement, triggerField) {
    try {
        const row = inputElement.closest('tr');
        if (!row) return;

        const itemInput = row.querySelector('.item-name-input');
        const mijnTafelNameInput = row.querySelector('.mijn-tafel-name-input');

        if (!itemInput || !mijnTafelNameInput) {
            console.warn('Could not find item or Mijn Tafel Name input in the row for autofill.');
            return;
        }

        const itemName = itemInput.value.trim();
        const mijnTafelNameValue = mijnTafelNameInput.value.trim();

        if (triggerField === 'item' && itemName) {
            // Find latest purchase with this item name
            const latestPurchase = transactions
                .filter(t => t.type === 'purchase' && t.item === itemName && t.mijnTafelName) // Ensure it has a Mijn Tafel Name
                .sort((a, b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date))[0];

            if (latestPurchase) {
                mijnTafelNameInput.value = latestPurchase.mijnTafelName; // Autofill Mijn Tafel Name
            }
        } else if (triggerField === 'mijnTafelName' && mijnTafelNameValue) {
            // Find latest purchase with this Mijn Tafel Name
            const latestPurchase = transactions
                .filter(t => t.type === 'purchase' && t.mijnTafelName === mijnTafelNameValue && t.item) // Ensure it has an item name
                .sort((a, b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date))[0];

            if (latestPurchase) {
                itemInput.value = latestPurchase.item; // Autofill Item Name
            }
        }
    } catch (e) {
        console.error('Error in autoFillPurchaseFields:', e);
    }
}


// --- Monthly/Yearly Sales Modals ---
function openMonthlySalesModal() {
    try {
        const modal = document.getElementById('monthlySalesModal');
        if (!modal) throw new Error('Monthly sales modal element not found');

        const monthSelector = document.getElementById('monthSelector');
        if (!monthSelector) throw new Error('Month selector element not found');

        monthSelector.innerHTML = ''; // Clear previous options
        const uniqueMonths = [...new Set(
            transactions
                .filter(t => t.type === 'sale' && t.date && /^\d{2}\/\d{2}\/\d{4}$/.test(t.date)) // Ensure valid date format
                .map(t => {
                    const parts = t.date.split('/');
                    return `${parts[2]}-${parts[1]}`; // YYYY-MM format
                })
        )].sort().reverse(); // Sort YYYY-MM descending

        if (uniqueMonths.length === 0) {
            const option = document.createElement('option');
            option.textContent = "No Sales Recorded";
            option.value = "";
            monthSelector.appendChild(option);
            monthSelector.disabled = true;
        } else {
            monthSelector.disabled = false;
            uniqueMonths.forEach(month => {
                const [year, m] = month.split('-');
                const option = document.createElement('option');
                option.value = month; // Store YYYY-MM
                // Display full month name and year
                const monthDate = new Date(year, parseInt(m) - 1); // Month is 0-indexed
                option.textContent = monthDate.toLocaleString('en', { month: 'long', year: 'numeric' });
                monthSelector.appendChild(option);
            });
            monthSelector.value = uniqueMonths[0]; // Select the latest month by default
        }

        // Set default date for new sale input to today
        // Use the remembered date, or today if none stored yet
	const defaultDate = lastMonthlySaleDate || getTodayStrLocal();
	document.getElementById('newSaleDate').value = defaultDate;
        setDateLimits(); // Ensure max date is set for the new sale input

        updateMonthlySalesTable(); // Populate table for the selected month
        monthlySalesDirty = false;
	toggleMonthlySaveBtn(false);
	modal.style.display = 'block';
        console.log('Monthly sales modal opened');
    } catch (e) {
        console.error('Error in openMonthlySalesModal:', e);
        alert('Could not open monthly sales window.');
    }
}

function updateMonthlySalesTable() {
    try {
        const tableBody = document.getElementById('monthlySalesBody');
        const totalSumElement = document.getElementById('monthlySalesTotalSum');
        const monthSelector = document.getElementById('monthSelector');
        if (!tableBody || !totalSumElement || !monthSelector) {
            console.warn('Monthly sales table elements not found');
            return;
        }
        tableBody.innerHTML = '';
        const selectedMonth = monthSelector.value; // YYYY-MM
        console.log(`updateMonthlySalesTable: Selected month: ${selectedMonth}`);
        if (!selectedMonth) {
            tableBody.innerHTML = '<tr><td colspan="8" style="text-align: center;">Please select a month</td></tr>';
            totalSumElement.textContent = euro.format(0);
            console.log('updateMonthlySalesTable: No month selected, showing placeholder');
            return;
        }

        // Filter sales by matching YYYY-MM
        const sales = transactions.filter(t => {
            if (t.type !== 'sale' || !t.date) return false;
            const dateParts = t.date.split('/');
            if (dateParts.length !== 3) {
                console.warn(`Invalid date format for transaction: ${t.date}`);
                return false;
            }
            const yearMonth = `${dateParts[2]}-${dateParts[1]}`; // e.g., 2025-04
            return yearMonth === selectedMonth;
        });
        console.log(`updateMonthlySalesTable: Found ${sales.length} sales for ${selectedMonth}`);

        let totalSum = 0;
        const todayDate = new Date();
        todayDate.setHours(0, 0, 0, 0);
        const today = getTodayStrLocal(false); // Use next day for max
        console.log(`updateMonthlySalesTable: Using max date ${today} for dynamic inputs`);

        if (sales.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="8" style="text-align: center;">No sales recorded for this month</td></tr>';
            console.log('updateMonthlySalesTable: No sales found, showing empty message');
        } else {
            sales.forEach((sale, index) => {
                totalSum += sale.total || 0;
                const row = tableBody.insertRow();
                row.innerHTML = `
                    <td><input type="date" value="${formatDateForInput(sale.date)}" max="${today}" onchange="updateMonthlySalesRow(this, ${index})" /></td>
                    <td>${sale.item || 'N/A'}</td>
                    <td>${sale.mijnTafelName || ''}</td>
                    <td><input type="number" min="1" value="${sale.qty || 1}" onchange="updateMonthlySalesRow(this, ${index})" /></td>
                    <td><input type="number" step="0.01" min="0" value="${sale.price || 0}" onchange="updateMonthlySalesRow(this, ${index})" /></td>
                    <td>${euro.format(sale.total || 0)}</td>
                    <td><input type="text" value="${sale.tablePlace || ''}" onchange="updateMonthlySalesRow(this, ${index})" /></td>
                    <td><button onclick="deleteMonthlySale(${index})">Delete</button></td>
                `;
            });
        }
        totalSumElement.textContent = euro.format(totalSum);
        setDateLimits();
        console.log(`updateMonthlySalesTable: Table updated with ${sales.length} rows, total sum ${euro.format(totalSum)}`);
    } catch (e) {
        console.error('Error in updateMonthlySalesTable:', e);
        const tableBody = document.getElementById('monthlySalesBody');
        if (tableBody) {
            tableBody.innerHTML = '<tr><td colspan="8" class="text-center text-red-400 py-4">Error loading monthly sales</td></tr>';
        }
    }
}

function saveMonthlySalesChanges() {
    if (!monthlySalesDirty) return;              // nothing to do
    // 1) validate & write the values back into the transactions array
    const rows = document.querySelectorAll('#monthlySalesBody tr:not(.date-group-header)');
    rows.forEach(row => {
        const cells = row.cells;
        if (cells.length < 7) return;            // safety
        const idx = parseInt(cells[0].querySelector('input')?.getAttribute('data-idx'));
        if (isNaN(idx) || idx < 0 || idx >= transactions.length) return;

        const sale = transactions[idx];
        if (!sale || sale.type !== 'sale') return;

        // Read the current input values (already validated when the user typed)
        sale.date       = formatEuropeanDate(new Date(cells[0].querySelector('input').value));
        sale.qty        = parseInt   (cells[3].querySelector('input').value);
        sale.price      = parseFloat (cells[4].querySelector('input').value);
        sale.total      = sale.qty * sale.price;
        sale.tablePlace = cells[6].querySelector('input').value.trim();
    });

    // 2) persist & refresh everything
    saveData();
    updateMonthlySalesTable();
    updateSalesHistoryTable();
    updateDashboard();
    updateCashFlowTable();

    // 3) reset flag + button
    monthlySalesDirty = false;
    toggleMonthlySaveBtn(false);
}

function toggleMonthlySaveBtn(on) {
    const btn = document.getElementById('monthlySaveBtn');
    if (!btn) return;
    btn.disabled = !on;
    btn.style.background = on ? '#e0e0e0' : '#bfbfbf';
    btn.style.cursor     = on ? 'pointer' : 'not-allowed';
}

function monthlyCellEdited(el) {
  // 1) your existing “dirty” flag + save button
  monthlySalesDirty = true;
  toggleMonthlySaveBtn(true);

  // 2) recalc this row’s Total (cells[3]=Qty, [4]=Price, [5]=Total)
  const row   = el.closest('tr');
  const cells = row.cells;
  const qtyIn  = cells[3].querySelector('input');
  const prcIn  = cells[4].querySelector('input');
  if (!qtyIn || !prcIn) return;        // guard
  const qty   = parseFloat(qtyIn.value)   || 0;
  const price = parseFloat(prcIn.value)   || 0;
  const newTotal = qty * price;
  if (cells[5]) cells[5].textContent = euro.format(newTotal);

  // 3) recalc the Subtotal for this date group
  const tbody = row.parentNode;
  const rows  = Array.from(tbody.rows);
  let i = rows.indexOf(row);
  // walk back to the date header
  while (i >= 0 && !rows[i].classList.contains('date-group-header')) {
    i--;
  }
  if (i >= 0) {
    let subSum = 0;
    for (let j = i + 1; j < rows.length; j++) {
      const r = rows[j];
      // next header? stop.
      if (r.classList.contains('date-group-header')) break;
      // subtotal row? write it and stop.
      if (r.cells[0].colSpan >= 5) {
            // ✅ the subtotal amount lives in the *second* cell (index 1)
            if (r.cells[1]) r.cells[1].textContent = euro.format(subSum);
            break;
        }

      // otherwise it’s a data row—add its total
      const txt = r.cells[5]?.textContent || '';
      const val = parseFloat(txt.replace(/[^0-9\-,\.]/g, '').replace(',', '.')) || 0;
      subSum += val;
    }
  }

  // 4) (Optional) recalc the grand total at the bottom
  const grandEl = document.getElementById('monthlySalesTotalSum');
  if (grandEl) {
    let grandSum = 0;
    rows.forEach(r => {
      if (r.classList.contains('date-group-header')) return;
      if (r.cells[0].colSpan >= 5) return; // skip subtotals
      const txt = r.cells[5]?.textContent || '';
      const v   = parseFloat(txt.replace(/[^0-9\-,\.]/g, '').replace(',', '.')) || 0;
      grandSum += v;
    });
    grandEl.textContent = euro.format(grandSum);
  }
}


function deleteMonthlySale(index) {
    try {
        // Validate index
        if (!Number.isInteger(index) || index < 0 || index >= transactions.length) {
            console.error('Invalid sale index:', index);
            alert('Error: Invalid sale selected for deletion.');
            return;
        }

        const sale = transactions[index];
        if (!sale || sale.type !== 'sale') {
            console.error('Sale not found or not a sale at index:', index, sale);
            alert('Error: Sale record not found.');
            return;
        }

        // Confirm deletion
        if (!confirm(`Are you sure you want to delete the sale for "${sale.item}" on ${sale.date}?`)) {
            return;
        }

        // Add back the sold quantity to inventory
        const item = sale.item;
        const qty = parseInt(sale.qty) || 0;
        if (item && qty > 0) {
            inventory[item] = (inventory[item] || 0) + qty;
            console.log(`Restored ${qty} units of "${item}" to inventory. New qty: ${inventory[item]}`);
        } else {
            console.warn('No valid item or quantity to restore:', { item, qty });
        }

        // Remove the sale from transactions
        transactions.splice(index, 1);
        console.log('Sale deleted at index:', index);

        // Save updated data
        saveData();

        // Refresh UI
        updateMonthlySalesTable();
        updateSalesHistoryTable();
        updateCashFlowTable();
        updateInventoryTable();
        updateDashboard();
        updateSaleItemList();

        console.log('Sale deleted successfully, UI updated.');
    } catch (e) {
        console.error('Error in deleteMonthlySale:', e);
        alert('Failed to delete sale. Check the console for details.');
    }
}

function editMonthlySale(originalIndex, field, value) {
    try {
        // Validate index
        if (originalIndex < 0 || originalIndex >= transactions.length) {
            alert('Error: Invalid sale reference for editing.');
            console.error("Invalid index passed to editMonthlySale:", originalIndex);
            updateMonthlySalesTable(); // Refresh table to revert visual change
            return;
        }

        const sale = transactions[originalIndex];
        if (!sale || sale.type !== 'sale') {
            alert('Error: Sale record not found.');
            console.error("Sale not found at index:", originalIndex);
            updateMonthlySalesTable(); // Refresh table
            return;
        }

        let needsRecalculate = false;
        const oldQty = sale.qty;
        let formattedDate = sale.date; // Keep original date unless changed

        switch (field) {
            case 'date':
                const newDate = new Date(value); // Parse YYYY-MM-DD
                if (isNaN(newDate.getTime())) {
                    alert('Invalid date selected.');
                    updateMonthlySalesTable(); // Revert display
                    return;
                }
                 // Check if date is in the future
                 const today = new Date(); today.setHours(0,0,0,0);
                 today.setHours(0,0,0,0);
		 date.setHours(0, 0, 0, 0);	
                 if (date.getTime() > today.getTime()) { // today allowed
                      alert("Sale date cannot be in the future.");
                      updateMonthlySalesTable(); // Revert display
                      return;
                 }
                formattedDate = formatEuropeanDate(newDate); // Convert to DD/MM/YYYY
                sale.date = formattedDate;
                break;
            case 'qty':
                const newQty = parseInt(value);
                if (isNaN(newQty) || newQty <= 0) {
                    alert('Invalid quantity. Please enter a number greater than 0.');
                    updateMonthlySalesTable(); // Revert display
                    return;
                }
                 // Check inventory
                 const availableBeforeThisSale = (inventory[sale.item] || 0) + oldQty;
                 if (availableBeforeThisSale < newQty) {
                      alert(`Not enough inventory to increase sale quantity for "${sale.item}". Available (excluding original sale): ${availableBeforeThisSale - oldQty}. Required: ${newQty}`);
                      updateMonthlySalesTable(); // Revert display
                      return;
                 }
                sale.qty = newQty;
                sale.total = newQty * (sale.price || 0); // Recalculate total
                needsRecalculate = true; // Inventory changed
                break;
            case 'price':
                const newPrice = parseFloat(value);
                if (isNaN(newPrice) || newPrice < 0) { // Price can be 0
                    alert('Invalid price. Please enter a non-negative number.');
                     updateMonthlySalesTable(); // Revert display
                    return;
                }
                sale.price = newPrice;
                sale.total = (sale.qty || 0) * newPrice; // Recalculate total
                break;
            case 'tablePlace':
                sale.tablePlace = value.trim();
                break;
            default:
                console.warn('Unknown field edited in monthly sale:', field);
                return; // Don't save if field is unknown
        }

        // Save data and update relevant parts
        if (needsRecalculate) {
            recalculateInventory(); // Calls saveData, updates inventory table, lists etc.
        } else {
            saveData(); // Save only transaction change if inventory wasn't affected
        }

        updateMonthlySalesTable(); // Refresh and re-sort the modal table
        updateSalesHistoryTable(); // Update main sales history if date changed etc.
        updateDashboard(); // Update dashboard figures
        updateCashFlowTable(); // Update cash flow

        console.log(`Monthly sale ${field} updated for index:`, originalIndex, "New value:", value);

    } catch (e) {
        console.error('Error in editMonthlySale:', e);
        alert('An error occurred while updating the sale.');
        updateMonthlySalesTable(); // Attempt to revert display on error
    }
}


function addSaleFromModal() {
    try {
        const itemInput = document.getElementById('newSaleItem');
        const mijnTafelNameInput = document.getElementById('newSaleMijnTafelName');
        const qtyInput = document.getElementById('newSaleQty');
        const priceInput = document.getElementById('newSalePrice');
        const tablePlaceInput = document.getElementById('newSaleTablePlace');
        const dateInput = document.getElementById('newSaleDate');

        const item = itemInput.value.trim();
        const mijnTafelName = mijnTafelNameInput.value.trim();
        const qty = parseInt(qtyInput.value);
        const price = parseFloat(priceInput.value);
        const tablePlace = tablePlaceInput.value.trim();
        const dateValue = dateInput.value; // YYYY-MM-DD

        if (!item || isNaN(qty) || qty <= 0 || isNaN(price) || price < 0 || !dateValue) {
            alert('Please fill Item Name, Quantity (>0), Price (>=0), and Date correctly.');
            return;
        }

        // Check inventory
        if (!inventory[item] || inventory[item] < qty) {
            alert(`Not enough inventory for "${item}". Available: ${inventory[item] || 0}`);
            return;
        }

        const date = new Date(dateValue);
        if (isNaN(date.getTime())) {
            alert('Invalid date selected.');
            return;
        }
        const formattedDate = formatEuropeanDate(date); // Convert to DD/MM/YYYY

        // Check if date is in the future
        const today = new Date(); today.setHours(0,0,0,0);
        today.setHours(0, 0, 0, 0);
	date.setHours(0, 0, 0, 0);	
        if (date.getTime() > today.getTime()) { // today allowed
            alert("Sale date cannot be in the future.");
            return;
        }

        const total = qty * price;
        transactions.push({
            type: 'sale',
            item,
            mijnTafelName: mijnTafelName || '',
            qty,
            price,
            total,
            tablePlace: tablePlace || '',
            date: formattedDate
        });

        recalculateInventory(); // Updates inventory, calls saveData, etc.
        updateMonthlySalesTable(); // Refresh and sort modal table
        updateSalesHistoryTable(); // Refresh main history
        updateDashboard();
        updateCashFlowTable();

        // Clear modal input fields
        itemInput.value = '';
        mijnTafelNameInput.value = '';
        qtyInput.value = '';
        priceInput.value = '';
        tablePlaceInput.value = '';
        /* Remember the date that was just used */
	lastMonthlySaleDate = dateValue;                 // YYYY-MM-DD
	localStorage.setItem('lastMonthlySaleDate', dateValue);

	/* Pre-fill the next line with that same date */
	dateInput.value = lastMonthlySaleDate;

        console.log('Sale added from modal:', { item, mijnTafelName, qty, price, total, tablePlace, date: formattedDate });
    } catch (e) {
        console.error('Error in addSaleFromModal:', e);
        alert('An error occurred while adding the sale from the modal.');
    }
}

function openYearlySalesModal() {
    try {
        const modal = document.getElementById('yearlySalesModal');
        if (!modal) throw new Error('Yearly sales modal element not found');

        const canvas = document.getElementById('yearlySalesChart');
        if (!canvas) throw new Error('Yearly sales chart canvas not found');

        const ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('Could not get canvas context');

        // Destroy previous chart instance if it exists
        if (canvas.chartInstance) {
            canvas.chartInstance.destroy();
        }

        const yearlyData = {};
        transactions
            .filter(t => t.type === 'sale' && t.date && /^\d{2}\/\d{2}\/\d{4}$/.test(t.date))
            .forEach(t => {
                const year = t.date.split('/')[2];
                yearlyData[year] = (yearlyData[year] || 0) + (t.total || 0);
            });

        const labels = Object.keys(yearlyData).sort(); // Sort years chronologically
        const data = labels.map(year => yearlyData[year]);

        if (labels.length === 0) {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            ctx.font = "16px Arial";
            ctx.fillStyle = "#888";
            ctx.textAlign = "center";
            ctx.fillText("No sales data available for chart.", canvas.width / 2, canvas.height / 2);
        } else {
            canvas.chartInstance = new Chart(ctx, { // Store instance on canvas element
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Total Sales (€)',
                        data,
                        backgroundColor: 'rgba(75, 192, 192, 0.6)', // Slightly darker color
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Allow chart to fill modal height better
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                // Format Y-axis ticks as currency
                                callback: function(value, index, values) {
                                    return euro.format(value);
                                }
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                // Format tooltip value as currency
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += euro.format(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }
        modal.style.display = 'block';
        console.log('Yearly sales modal opened');
    } catch (e) {
        console.error('Error in openYearlySalesModal:', e);
        alert('Could not generate yearly sales chart.');
    }
}

// --- Supplier Handling ---
function openSupplierModal() {
    try {
        const modal = document.getElementById('supplierModal');
        if (modal) {
            document.getElementById('newSupplierName').value = ''; // Clear input
            modal.style.display = 'block';
        } else {
            console.warn('Supplier modal element not found');
        }
    } catch (e) {
        console.error('Error in openSupplierModal:', e);
    }
}

function addSupplier() {
    try {
        const nameInput = document.getElementById('newSupplierName');
        const name = nameInput.value.trim();
        if (!name) {
            alert('Please enter a supplier name.');
            return;
        }
        // Case-insensitive check for existing supplier
        if (suppliers.some(s => s.toLowerCase() === name.toLowerCase())) {
            alert(`Supplier "${name}" already exists.`);
            return;
        }
        suppliers.push(name);
        suppliers.sort((a, b) => a.localeCompare(b)); // Keep sorted
        saveData();
        updateSupplierDropdowns(); // Update all relevant dropdowns and manage table
        closeModal('supplierModal');
        console.log('Supplier added:', name);
    } catch (e) {
        console.error('Error in addSupplier:', e);
        alert('An error occurred while adding the supplier.');
    }
}

function updateSupplierDropdowns() {
    try {
        const selects = [
            document.getElementById('purchaseSupplierModal'),
            document.getElementById('editSupplier')
        ];
        // Ensure suppliers array is sorted for consistent dropdown order
        suppliers.sort((a, b) => a.localeCompare(b));

        selects.forEach(select => {
            if (select) {
                const currentValue = select.value; // Preserve selection if possible
                select.innerHTML = '<option value="">Select Supplier</option>'; // Clear and add placeholder
                suppliers.forEach(supplier => {
                    const option = document.createElement('option');
                    option.value = supplier;
                    option.textContent = supplier;
                    select.appendChild(option);
                });
                // Restore selection if the value still exists in the updated list
                if (currentValue && suppliers.includes(currentValue)) {
                    select.value = currentValue;
                } else {
                    select.value = ""; // Reset if previous value is no longer valid
                }
            } else {
                 // console.warn("A supplier dropdown element was not found."); // Less critical warning
            }
        });
        // Update the management table as well, if it exists
        updateManageSuppliersTable();
    } catch (e) {
        console.error('Error in updateSupplierDropdowns:', e);
    }
}

function openManageSuppliersModal() {
    try {
        const modal = document.getElementById('manageSuppliersModal');
        if (modal) {
            document.getElementById('newSupplierInput').value = ''; // Clear input
            updateManageSuppliersTable(); // Populate the table
            modal.style.display = 'block';
        } else {
            console.warn('Manage suppliers modal element not found');
        }
    } catch (e) {
        console.error('Error in openManageSuppliersModal:', e);
    }
}

function updateManageSuppliersTable() {
    try {
        const tbody = document.getElementById('manageSuppliersBody');
        if (!tbody) {
            // This might happen if the modal isn't open/rendered yet, not necessarily an error
            // console.warn('Manage suppliers table body not found (may be expected if modal is closed)');
            return;
        }
        tbody.innerHTML = ''; // Clear existing rows
        // Sort suppliers for display in the manage table
        const sortedSuppliers = [...suppliers].sort((a, b) => a.localeCompare(b));

        if (sortedSuppliers.length === 0) {
             tbody.innerHTML = '<tr><td colspan="2" style="text-align: center;">No suppliers added yet</td></tr>';
        } else {
            sortedSuppliers.forEach(supplier => {
                // Find original index for actions (needed for edit/delete)
                const originalIndex = suppliers.findIndex(s => s === supplier);
                const row = tbody.insertRow();
                row.dataset.originalIndex = originalIndex; // Store index on the row

                // Cell for supplier name (editable)
                const nameCell = row.insertCell();
                nameCell.className = 'editable-cell';
                nameCell.innerHTML = `
                    <span>${supplier}</span>
                    <input type="text" value="${supplier}" style="display: none;">
                `;

                // Cell for actions
                const actionCell = row.insertCell();
                actionCell.innerHTML = `
                    <button onclick="enableSupplierEdit(this)">Edit</button>
                    <button onclick="deleteSupplier(${originalIndex})">Delete</button>
                `;
            });
        }
    } catch (e) {
        console.error('Error in updateManageSuppliersTable:', e);
         const tbody = document.getElementById('manageSuppliersBody');
         if(tbody) tbody.innerHTML = '<tr><td colspan="2" class="text-center text-red-400 py-4">Error loading suppliers</td></tr>';
    }
}

function enableSupplierEdit(button) {
    const row = button.closest('tr');
    if (!row) return;
    const cell = row.querySelector('.editable-cell');
    if (!cell) return;
    const span = cell.querySelector('span');
    const input = cell.querySelector('input');
    const originalIndex = row.dataset.originalIndex; // Get index from row data

    if (!span || !input || originalIndex === undefined) {
        console.error("Could not find elements for editing supplier in row:", row);
        return;
    }

    // Hide span, show input
    span.style.display = 'none';
    input.style.display = 'inline-block';
    input.focus();
    input.select(); // Select text for easy replacement

    // Change Edit button to Save
    button.textContent = 'Save';
    button.onclick = () => saveSupplierEdit(button); // Pass button reference

    // Add Cancel button
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.onclick = () => cancelSupplierEdit(button); // Pass Edit/Save button reference
    button.parentNode.insertBefore(cancelButton, button.nextSibling);
}

function cancelSupplierEdit(button) {
    const row = button.closest('tr');
    if (!row) return;
    const cell = row.querySelector('.editable-cell');
    if (!cell) return;
    const span = cell.querySelector('span');
    const input = cell.querySelector('input');
    const cancelButton = button.nextSibling; // Assuming cancel is always next

    if (!span || !input || !cancelButton || cancelButton.textContent !== 'Cancel') {
         console.error("Could not find elements for cancelling supplier edit:", row);
        return;
    }

    // Hide input, show span
    input.style.display = 'none';
    span.style.display = 'inline-block';
    input.value = span.textContent; // Reset input value to original

    // Restore Edit button
    button.textContent = 'Edit';
    button.onclick = () => enableSupplierEdit(button);

    // Remove Cancel button
    cancelButton.remove();
}


function saveSupplierEdit(button) {
    const row = button.closest('tr');
    if (!row) return;
    const cell = row.querySelector('.editable-cell');
    if (!cell) return;
    const input = cell.querySelector('input');
    const originalIndex = parseInt(row.dataset.originalIndex); // Get index from row data

    if (!input || isNaN(originalIndex) || originalIndex < 0 || originalIndex >= suppliers.length) {
        console.error("Could not find elements or valid index for saving supplier edit:", row);
        alert("Error: Could not save supplier edit.");
        return;
    }

    const newName = input.value.trim();
    const oldName = suppliers[originalIndex];

    if (!newName) {
        alert('Supplier name cannot be empty.');
        input.focus(); // Keep focus on input
        return;
    }

    // Case-insensitive check if new name already exists (and it's not the original name being saved again)
    if (newName.toLowerCase() !== oldName.toLowerCase() &&
        suppliers.some(s => s.toLowerCase() === newName.toLowerCase())) {
        alert(`Supplier name "${newName}" already exists.`);
        input.focus();
        return;
    }

    // Update suppliers array
    suppliers[originalIndex] = newName;
    suppliers.sort((a, b) => a.localeCompare(b)); // Re-sort after edit

    // Update associated transactions
    let updatedCount = 0;
    transactions.forEach(t => {
        if (t.type === 'purchase' && t.supplier === oldName) {
            t.supplier = newName;
            updatedCount++;
        }
    });

    saveData();
    updateSupplierDropdowns(); // This redraws the manage table and updates dropdowns
    // The table redraw automatically handles reverting the input field back to a span
    console.log(`Supplier "${oldName}" updated to "${newName}". ${updatedCount} purchase record(s) updated.`);
    alert(`Supplier "${oldName}" updated to "${newName}". ${updatedCount} purchase record(s) updated.`);

}


function addSupplierFromManage() {
    try {
        const nameInput = document.getElementById('newSupplierInput');
        const name = nameInput.value.trim();
        if (!name) {
            alert('Please enter a supplier name.');
            return;
        }
        // Case-insensitive check
        if (suppliers.some(s => s.toLowerCase() === name.toLowerCase())) {
            alert(`Supplier "${name}" already exists.`);
            return;
        }
        suppliers.push(name);
        suppliers.sort((a, b) => a.localeCompare(b)); // Keep sorted
        saveData();
        updateSupplierDropdowns(); // Updates dropdowns and redraws manage table
        nameInput.value = ''; // Clear input field
        console.log('Supplier added from manage:', name);
    } catch (e) {
        console.error('Error in addSupplierFromManage:', e);
        alert('An error occurred while adding the supplier.');
    }
}

function deleteSupplier(originalIndex) {
    try {
        // Validate index
        if (originalIndex < 0 || originalIndex >= suppliers.length) {
            alert("Error: Invalid supplier reference.");
            console.error("Invalid index passed to deleteSupplier:", originalIndex);
            return;
        }
        const supplierToDelete = suppliers[originalIndex];

        // Check if supplier is used in any purchase transactions
        const isUsed = transactions.some(t => t.type === 'purchase' && t.supplier === supplierToDelete);
        if (isUsed) {
            alert(`Cannot delete supplier "${supplierToDelete}" as it is linked to existing purchase records. Please edit or delete the purchases first.`);
            return;
        }

        if (!confirm(`Are you sure you want to delete supplier "${supplierToDelete}"? This cannot be undone.`)) return;

        suppliers.splice(originalIndex, 1); // Remove from array
        // No need to re-sort here, will be sorted on next update
        saveData();
        updateSupplierDropdowns(); // Redraws manage table and updates dropdowns
        console.log('Supplier deleted:', supplierToDelete);
        alert(`Supplier "${supplierToDelete}" deleted.`);
    } catch (e) {
        console.error('Error in deleteSupplier:', e);
        alert('An error occurred while deleting the supplier.');
    }
}

// --- Category Handling ---
function openCategoryModal() {
    try {
        const modal = document.getElementById('categoryModal');
        if (modal) {
             document.getElementById('newCategoryName').value = ''; // Clear input
            modal.style.display = 'block';
        } else {
            console.warn('Category modal element not found');
        }
    } catch (e) {
        console.error('Error in openCategoryModal:', e);
    }
}

function addCategory() {
    try {
        const nameInput = document.getElementById('newCategoryName');
        const name = nameInput.value.trim();
        if (!name) {
            alert('Please enter a category name.');
            return;
        }
        // Case-insensitive check
        if (categories.some(c => c.toLowerCase() === name.toLowerCase())) {
            alert(`Category "${name}" already exists.`);
            return;
        }
        categories.push(name);
        categories.sort((a, b) => a.localeCompare(b)); // Keep sorted
        saveData();
        updateCategoryDropdowns(); // Update all relevant dropdowns
        closeModal('categoryModal');
        console.log('Category added:', name);
    } catch (e) {
        console.error('Error in addCategory:', e);
        alert('An error occurred while adding the category.');
    }
}

// Modified to update all category dropdowns or a specific one
function updateCategoryDropdowns(targetSelect = null) {
    try {
        // Determine which select elements to update
        const selectsToUpdate = targetSelect ? [targetSelect] : document.querySelectorAll('.category-select');
        if (selectsToUpdate.length === 0 && !targetSelect) return; // Nothing to update

        // Ensure categories array is sorted
        categories.sort((a, b) => a.localeCompare(b));

        selectsToUpdate.forEach(select => {
            if (select) {
                const currentValue = select.value; // Preserve selection
                select.innerHTML = '<option value="">Select Category</option>'; // Clear and add placeholder
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    select.appendChild(option);
                });
                 // Restore selection if the value still exists
                if (currentValue && categories.includes(currentValue)) {
                    select.value = currentValue;
                } else {
                    select.value = ""; // Reset if previous value is no longer valid
                }
            }
        });
         // Update the management table as well if it exists and we're doing a full update
        if (!targetSelect) {
             updateManageCategoriesTable();
        }
    } catch (e) {
        console.error('Error in updateCategoryDropdowns:', e);
    }
}


function openManageCategoriesModal() {
    try {
        const modal = document.getElementById('manageCategoriesModal');
        if (modal) {
            document.getElementById('newCategoryInput').value = ''; // Clear input
            updateManageCategoriesTable(); // Populate table
            modal.style.display = 'block';
        } else {
            console.warn('Manage categories modal element not found');
        }
    } catch (e) {
        console.error('Error in openManageCategoriesModal:', e);
    }
}

function updateManageCategoriesTable() {
    try {
        const tbody = document.getElementById('manageCategoriesBody');
        if (!tbody) {
            // console.warn('Manage categories table body not found (may be expected if modal is closed)');
            return;
        }
        tbody.innerHTML = ''; // Clear existing rows
        const sortedCategories = [...categories].sort((a, b) => a.localeCompare(b));

        if (sortedCategories.length === 0) {
             tbody.innerHTML = '<tr><td colspan="2" style="text-align: center;">No categories added yet</td></tr>';
        } else {
            sortedCategories.forEach(category => {
                 // Find original index for actions
                const originalIndex = categories.findIndex(c => c === category);
                const row = tbody.insertRow();
                row.dataset.originalIndex = originalIndex; // Store index

                // Name cell
                const nameCell = row.insertCell();
                nameCell.className = 'editable-cell';
                nameCell.innerHTML = `
                    <span>${category}</span>
                    <input type="text" value="${category}" style="display: none;">
                `;

                // Action cell
                const actionCell = row.insertCell();
                actionCell.innerHTML = `
                    <button onclick="enableCategoryEdit(this)">Edit</button>
                    <button onclick="deleteCategory(${originalIndex})">Delete</button>
                `;
            });
        }
    } catch (e) {
        console.error('Error in updateManageCategoriesTable:', e);
         const tbody = document.getElementById('manageCategoriesBody');
         if(tbody) tbody.innerHTML = '<tr><td colspan="2" class="text-center text-red-400 py-4">Error loading categories</td></tr>';
    }
}

function enableCategoryEdit(button) {
    const row = button.closest('tr');
    if (!row) return;
    const cell = row.querySelector('.editable-cell');
    if (!cell) return;
    const span = cell.querySelector('span');
    const input = cell.querySelector('input');
    const originalIndex = row.dataset.originalIndex;

    if (!span || !input || originalIndex === undefined) {
         console.error("Could not find elements for editing category in row:", row);
        return;
    }

    span.style.display = 'none';
    input.style.display = 'inline-block';
    input.focus();
    input.select();

    button.textContent = 'Save';
    button.onclick = () => saveCategoryEdit(button);

    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.onclick = () => cancelCategoryEdit(button);
    button.parentNode.insertBefore(cancelButton, button.nextSibling);
}

function cancelCategoryEdit(button) {
    const row = button.closest('tr');
    if (!row) return;
    const cell = row.querySelector('.editable-cell');
     if (!cell) return;
    const span = cell.querySelector('span');
    const input = cell.querySelector('input');
    const cancelButton = button.nextSibling;

     if (!span || !input || !cancelButton || cancelButton.textContent !== 'Cancel') {
        console.error("Could not find elements for cancelling category edit:", row);
        return;
    }

    input.style.display = 'none';
    span.style.display = 'inline-block';
    input.value = span.textContent;

    button.textContent = 'Edit';
    button.onclick = () => enableCategoryEdit(button);

    cancelButton.remove();
}


function saveCategoryEdit(button) {
    const row = button.closest('tr');
     if (!row) return;
    const cell = row.querySelector('.editable-cell');
     if (!cell) return;
    const input = cell.querySelector('input');
    const originalIndex = parseInt(row.dataset.originalIndex);

     if (!input || isNaN(originalIndex) || originalIndex < 0 || originalIndex >= categories.length) {
        console.error("Could not find elements or valid index for saving category edit:", row);
        alert("Error: Could not save category edit.");
        return;
    }

    const newName = input.value.trim();
    const oldName = categories[originalIndex];

    if (!newName) {
        alert('Category name cannot be empty.');
        input.focus();
        return;
    }

    // Case-insensitive check if new name exists (and isn't the original)
    if (newName.toLowerCase() !== oldName.toLowerCase() &&
        categories.some(c => c.toLowerCase() === newName.toLowerCase())) {
        alert(`Category name "${newName}" already exists.`);
        input.focus();
        return;
    }

    // Update categories array
    categories[originalIndex] = newName;
    categories.sort((a, b) => a.localeCompare(b)); // Re-sort

    // Update associated transactions
    let updatedCount = 0;
    transactions.forEach(t => {
        // Check if transaction has a category and it matches the old name
        if (t.type === 'purchase' && t.category === oldName) {
            t.category = newName;
            updatedCount++;
        }
    });

    saveData();
    updateCategoryDropdowns(); // Redraws manage table and updates dropdowns
    console.log(`Category "${oldName}" updated to "${newName}". ${updatedCount} purchase item(s) updated.`);
    alert(`Category "${oldName}" updated to "${newName}". ${updatedCount} purchase item(s) updated.`);
}


function addCategoryFromManage() {
    try {
        const nameInput = document.getElementById('newCategoryInput');
        const name = nameInput.value.trim();
        if (!name) {
            alert('Please enter a category name.');
            return;
        }
        // Case-insensitive check
        if (categories.some(c => c.toLowerCase() === name.toLowerCase())) {
            alert(`Category "${name}" already exists.`);
            return;
        }
        categories.push(name);
        categories.sort((a, b) => a.localeCompare(b)); // Keep sorted
        saveData();
        updateCategoryDropdowns(); // Updates dropdowns and redraws manage table
        nameInput.value = ''; // Clear input field
        console.log('Category added from manage:', name);
    } catch (e) {
        console.error('Error in addCategoryFromManage:', e);
        alert('An error occurred while adding the category.');
    }
}

function deleteCategory(originalIndex) {
    try {
        // Validate index
        if (originalIndex < 0 || originalIndex >= categories.length) {
            alert("Error: Invalid category reference.");
            console.error("Invalid index passed to deleteCategory:", originalIndex);
            return;
        }
        const categoryToDelete = categories[originalIndex];

        // Check if category is used in any purchase transactions
        const isUsed = transactions.some(t => t.type === 'purchase' && t.category === categoryToDelete);
        if (isUsed) {
            alert(`Cannot delete category "${categoryToDelete}" as it is linked to existing purchase items. Please edit the items first.`);
            return;
        }

        if (!confirm(`Are you sure you want to delete category "${categoryToDelete}"? This cannot be undone.`)) return;

        categories.splice(originalIndex, 1); // Remove from array
        saveData();
        updateCategoryDropdowns(); // Redraws manage table and updates dropdowns
        console.log('Category deleted:', categoryToDelete);
        alert(`Category "${categoryToDelete}" deleted.`);
    } catch (e) {
        console.error('Error in deleteCategory:', e);
        alert('An error occurred while deleting the category.');
    }
}

// --- Purchase Handling ---
function openPurchaseModal() {
    try {
        const modal = document.getElementById('purchaseModal');
        if (!modal) throw new Error('Purchase modal element not found');

        // Reset fields
        document.getElementById('purchaseDateModal').value = getTodayStrLocal(); // Default to today
        document.getElementById('purchaseSupplierModal').value = '';
        document.getElementById('purchaseOrderNumberModal').value = '';
        document.getElementById('purchaseDiscountModal').value = '';
        document.getElementById('purchaseItemsBody').innerHTML = ''; // Clear items table

        updateSupplierDropdowns(); // Ensure supplier list is current
        updateCategoryDropdowns(); // Ensure category list is ready for potential rows
        updatePurchaseTotal(); // Calculate initial total (should be 0)
        setDateLimits(); // Set max date

        modal.style.display = 'block';
        console.log('Purchase modal opened');
    } catch (e) {
        console.error('Error in openPurchaseModal:', e);
        alert('Could not open purchase window.');
    }
}
/**
 * When the user selects an item (or Mijn Tafel Name),
 * look up the most recent purchase of that item
 * and fill its Price (€) field automatically.
 */
 function populatePurchasePrice(el) {
  const row = el.closest('tr');
  if (!row) return;
  // 1) Get the item name from this row
  const itemName = row.querySelector('.item-name-input')?.value.trim();
  if (!itemName) return;
  // 2) Filter to past purchase transactions for that item
  const past = transactions
    .filter(t => t.type === 'purchase' && t.item === itemName)
    .sort((a, b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date));
  if (past.length === 0) return;      // no history, nothing to fill
  // 3) Grab the very latest price
  const lastPrice = past[0].price;
  // 4) Write it into the Price input
  const priceIn = row.querySelector('.price-input');
  if (priceIn) priceIn.value = lastPrice.toFixed(2);
}

/**
 * Auto-fill the Category `<select>` from the most recent purchase.
 */
 function populatePurchaseCategory(el) {
  const row = el.closest('tr');
  if (!row) return;
  // Get the chosen item name
  const itemName = row.querySelector('.item-name-input')?.value.trim();
  if (!itemName) return;
  // Find past purchases of that item, newest first
  const past = transactions
    .filter(t => t.type === 'purchase' && t.item === itemName)
    .sort((a, b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date));
  if (past.length === 0) return;      // no history
  const lastCat = past[0].category;
  // Write it into the row’s select
  const selectEl = row.querySelector('.category-select');
  if (selectEl && lastCat != null) {
    selectEl.value = lastCat;
  }
}


// MODIFIED: Added oninput handlers for autofill
function addPurchaseItemRow() {
    try {
        const tbody = document.getElementById('purchaseItemsBody');
        if (!tbody) throw new Error('Purchase items table body not found');

        const row = tbody.insertRow();
        row.innerHTML = `
            <td><input class="item-name-input wide-input" placeholder="Item Name" type="text" list="inventoryItems" oninput="autoFillPurchaseFields(this, 'item'); populatePurchasePrice(this); populatePurchaseCategory(this)"></td>
            <td><input class="mijn-tafel-name-input wide-input" placeholder="Mijn Tafel Name" type="text" list="mijnTafelNames" oninput="autoFillPurchaseFields(this, 'mijnTafelName'); populatePurchasePrice(this); populatePurchaseCategory(this)"></td>
            <td><input class="qty-input" type="number" min="1" value="1" oninput="updatePurchaseRow(this)"></td>
            <td><input class="cost-input" type="number" step="0.01" min="0" value="0" oninput="updatePurchaseRow(this)"></td>
            <td class="total"><input class="total-input" type="number" step="0.01" min="0" value="0" oninput="updatePurchaseRow(this)"></td>
            <td class="discount">€0.00</td>
            <td class="net-cost">€0.00</td>
            <td><input class="price-input" type="number" step="0.01" min="0" value="0"></td>
            <td><select class="category-select"></select></td>
            <td><button type="button" onclick="removePurchaseItemRow(this)">Remove</button></td>
        `;
        updateCategoryDropdowns(row.querySelector('.category-select')); // Populate dropdown for the new row
        updatePurchaseTotal(); // Recalculate totals after adding row
    } catch (e) {
        console.error('Error in addPurchaseItemRow:', e);
        alert('Could not add item row to purchase.');
    }
}



function updatePurchaseRow(inputElement) {
    try {
        const row = inputElement.closest('tr');
        if (!row) return;
        const qtyInput = row.querySelector('.qty-input');
        const costInput = row.querySelector('.cost-input');
        const totalInput = row.querySelector('.total-input');
        const qty = parseFloat(qtyInput.value) || 0;
        let cost = parseFloat(costInput.value) || 0;
        if (inputElement.classList.contains('total-input')) {
            const totalVal = parseFloat(totalInput.value) || 0;
            cost = qty > 0 ? totalVal / qty : 0;
            costInput.value = cost;
        } else {
            const itemTotalCost = qty * cost;
            totalInput.value = itemTotalCost;
        }
        updatePurchaseTotal();
    } catch (e) {
        console.error('Error in updatePurchaseRow:', e);
    }
}



function removePurchaseItemRow(button) {
    try {
        const row = button.closest('tr');
        if (row) {
            row.remove();
            updatePurchaseTotal(); // Recalculate totals after removing row
        }
    } catch (e) {
        console.error('Error in removePurchaseItemRow:', e);
    }
}



function updatePurchaseTotal() {
    try {
        const rows = Array.from(document.getElementById('purchaseItemsBody')?.rows || []);
        const orderDiscountInput = document.getElementById('purchaseDiscountModal');
        const totalCostElement = document.getElementById('purchaseTotalCost');
        const discountTotalSumElement = document.getElementById('purchaseDiscountTotalSum');
        if (!orderDiscountInput || !totalCostElement || !discountTotalSumElement) return;

        const orderDiscount = parseFloat(orderDiscountInput.value) || 0;

        // First pass: compute gross costs and total gross
        let totalGross = 0;
        const grossCosts = [];
        for (let row of rows) {
            const qty = parseFloat(row.querySelector('.qty-input')?.value) || 0;
            const cost = parseFloat(row.querySelector('.cost-input')?.value) || 0;
            const gross = qty * cost;
            grossCosts.push({ gross, qty });
            totalGross += gross;
        }

            // —— LIVE per-row discount & net cost —— 
            rows.forEach((row, idx) => {
            const { gross, qty } = grossCosts[idx];
            // allocate discount by share of gross
            const rowDiscount = totalGross > 0
                ? (gross / totalGross) * orderDiscount
                : 0;
            const after    = gross - rowDiscount;
            const netEach  = qty > 0 ? after / qty : 0;
            // write into the two columns:
            const discCell = row.querySelector('.discount');
            const netCell  = row.querySelector('.net-cost');
            if (discCell) discCell.textContent = euro.format(after);
            if (netCell)  netCell.textContent  = euro.format(netEach);
            });
            // —— end live row update —— 

        // Apply order-level discount all at once
	const finalTotalCost = Math.max(0, totalGross - orderDiscount);


        // Update overall total
        totalCostElement.textContent = euro.format(finalTotalCost);
        discountTotalSumElement.textContent = euro.format(finalTotalCost);

    } catch (e) {
        console.error('Error in updatePurchaseTotal:', e);
    }
}



// MODIFIED: Added comment for date check
function savePurchaseFromModal() {
    try {
        // 1) Read inputs
        const dateInput = document.getElementById('purchaseDateModal');
        const supplierInput = document.getElementById('purchaseSupplierModal');
        const orderNumberInput = document.getElementById('purchaseOrderNumberModal');
        const orderDiscountInput = document.getElementById('purchaseDiscountModal');
        const rows = document.getElementById('purchaseItemsBody').rows;

        // 2) Basic validation
        const dateValue = dateInput.value; // YYYY-MM-DD
        const supplier = supplierInput.value.trim();
        const orderNumber = orderNumberInput.value.trim();
        const orderDiscount = parseFloat(orderDiscountInput.value) || 0;

        if (!dateValue || !supplier) {
            alert('Please select a Date and Supplier.');
            return;
        }
        if (rows.length === 0) {
            alert('Please add at least one item to the purchase.');
            return;
        }

        // 3) Parse & format date, forbid future dates
        const date = new Date(dateValue);
        if (isNaN(date.getTime())) {
            alert('Invalid date selected.');
            return;
        }
        date.setHours(0,0,0,0);
        const today = new Date(); today.setHours(0,0,0,0);
        if (date > today) {
            alert("Purchase date cannot be in the future.");
            return;
        }
        const formattedDate = formatEuropeanDate(date); // DD/MM/YYYY

        // 4) Gather and validate each row, compute totals
        let purchaseItems = [];
        let totalCostBeforeDiscount = 0;
        for (let row of rows) {
            const item        = row.querySelector('.item-name-input').value.trim();
            const mijnTafel   = row.querySelector('.mijn-tafel-name-input').value.trim();
            const qty         = parseInt(row.querySelector('.qty-input').value);
            const cost        = parseFloat(row.querySelector('.cost-input').value);
            const price       = parseFloat(row.querySelector('.price-input').value);
            const category    = row.querySelector('.category-select').value;

            if (!item || isNaN(qty) || qty <= 0 || isNaN(cost) || cost < 0 || isNaN(price) || price < 0) {
                alert(`Invalid data in item row: "${item || 'Unnamed Item'}". Please check Item Name, Quantity (>0), Cost (>=0), and Price (>=0).`);
                return;
            }

            const itemTotal = qty * cost;
            totalCostBeforeDiscount += itemTotal;
            purchaseItems.push({ item, mijnTafelName: mijnTafel, qty, cost, price, category, itemTotal });
        }

        // 5) Create transactions with **full-precision** net costs
        purchaseItems.forEach(pItem => {
            const proportion   = totalCostBeforeDiscount > 0
                                ? pItem.itemTotal / totalCostBeforeDiscount
                                : 0;
            const itemDiscount = orderDiscount * proportion;
            const itemNetExact = pItem.itemTotal - itemDiscount;

            transactions.push({
                type:         'purchase',
                item:          pItem.item,
                mijnTafelName: pItem.mijnTafelName,
                qty:           pItem.qty,
                cost:          pItem.cost,
                total:         itemNetExact,
                price:         pItem.price,
                date:          formattedDate,
                supplier,
                orderNumber,
                category:      pItem.category
            });
        });

        // 6) Update UI & storage
        recalculateInventory();
        updatePurchaseHistoryTable();
        updateDashboard();
        updateCashFlowTable();
        closeModal('purchaseModal');

        // 7) Compute and show the true net total
        const finalNetTotal = totalCostBeforeDiscount - orderDiscount;
        console.log('Purchase saved:', {
          date: formattedDate,
          supplier,
          orderNumber,
          totalCost: finalNetTotal
        });
        alert(`Purchase saved successfully. Total: ${euro.format(finalNetTotal)}`);

    } catch (e) {
        console.error('Error in savePurchaseFromModal:', e);
        alert('An error occurred while saving the purchase.');
    }
}


function updatePurchaseHistoryTable() {
   console.log("🧾 Purchases available in UI update:", purchases);
   console.log("📦 Updating Purchase History Table...");
   console.log("🧾 Purchases:", transactions.filter(t => t.type === "purchase"));
    const tbody = document.getElementById('purchaseHistoryBody');
    if (!tbody) return;
    tbody.innerHTML = '';
    // Group by date|supplier|orderNumber
    const groups = {};
    transactions.forEach((p, i) => {
        if (p.type === 'purchase') {
            const key = `${p.date}|${p.supplier}|${p.orderNumber || ''}`;
            if (!groups[key]) {
                groups[key] = { date: p.date, supplier: p.supplier, orderNumber: p.orderNumber || '', items: [], indices: [] };
            }
            groups[key].items.push(p);
            groups[key].indices.push(i);
        }
    });
    const keys = Object.keys(groups)
        .sort((a, b) => parseEuropeanDate(groups[b].date) - parseEuropeanDate(groups[a].date))
        .slice(0, 10);
    if (keys.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;">No purchases recorded</td></tr>';
    } else {
        keys.forEach(k => {
            const g = groups[k];
            const costBefore = g.items.reduce((sum, it) => sum + ((it.qty || 0) * (it.cost || 0)), 0);
            const totalCost = g.items.reduce((sum, it) => sum + (it.total || 0), 0);
            const discount = Math.max(0, costBefore - totalCost);
            const row = tbody.insertRow();
            row.innerHTML = `
                <td>${g.date}</td>
                <td>${g.supplier}</td>
                <td>${g.orderNumber}</td>
                <td>${euro.format(costBefore)}</td>
                <td>${euro.format(discount)}</td>
                <td>${euro.format(totalCost)}</td>
                <td>
                    <button onclick="openEditPurchaseModal(${JSON.stringify(g.indices)})">Edit</button>
                    <button onclick="deletePurchaseGroup(${JSON.stringify(g.indices)})">Delete</button>
                </td>`;
        });
        // View More button aligned left
        const moreRow = tbody.insertRow();
        const cell = moreRow.insertCell();
        cell.colSpan = 7;
        cell.style.textAlign = 'left';
        cell.innerHTML = '<button onclick="openAllPurchasesModal()">View More</button>';
    }
   console.log("✅ Purchase table update complete.");

}


function openEditPurchaseModal(originalIndices) {
    try {
        const modal = document.getElementById('editPurchaseModal');
        if (!modal) throw new Error('Edit purchase modal element not found');

        // Validate indices array
        if (!Array.isArray(originalIndices) || originalIndices.length === 0) {
             alert("Error: Invalid purchase selection for editing.");
             console.error("Invalid indices passed to openEditPurchaseModal:", originalIndices);
             return;
        }

        // Get the first purchase item to extract common data (date, supplier, order#)
        const firstPurchaseIndex = originalIndices[0];
         if (firstPurchaseIndex < 0 || firstPurchaseIndex >= transactions.length) {
            alert("Error: Invalid reference to purchase item.");
            console.error("Invalid first index:", firstPurchaseIndex);
            return;
        }
        const firstPurchase = transactions[firstPurchaseIndex];
        if (!firstPurchase || firstPurchase.type !== 'purchase') {
            alert("Error: Could not find valid purchase data to edit.");
             console.error("Item at first index is not a purchase:", firstPurchase);
            return;
        }

        // Store original indices and order number for saving later
        modal.dataset.originalIndices = JSON.stringify(originalIndices);
        modal.dataset.originalOrderNumber = firstPurchase.orderNumber || ''; // Store original order number

        // Populate common fields
        document.getElementById('editDate').value = formatDateForInput(firstPurchase.date); // Convert DD/MM/YYYY to YYYY-MM-DD
        document.getElementById('editSupplier').value = firstPurchase.supplier;
        document.getElementById('editOrderNumber').value = firstPurchase.orderNumber || '';

        // Calculate original total discount for the group
        const costBeforeDiscount = originalIndices.reduce((sum, index) => {
            const item = transactions[index];
            // Ensure item exists and has valid qty/cost before adding
            return sum + ((item?.qty || 0) * (item?.cost || 0));
        }, 0);
        const totalCost = originalIndices.reduce((sum, index) => sum + (transactions[index]?.total || 0), 0);
        const originalDiscount = Math.max(0, costBeforeDiscount - totalCost); // Ensure non-negative
        document.getElementById('editDiscount').value = originalDiscount > 0 ? originalDiscount : '';

        // Populate items table
        const tbody = document.getElementById('editItemsBody');
        tbody.innerHTML = ''; // Clear previous items
        originalIndices.forEach(index => {
            const item = transactions[index];
            if (!item || item.type !== 'purchase') {
                 console.warn(`Skipping invalid item at index ${index} during edit modal population.`);
                 return; // Skip if item is invalid or missing
            }
            const row = tbody.insertRow();
            row.dataset.originalIndex = index; // Store original index on row if needed later (e.g., for complex removal logic)
            // MODIFIED: Added oninput handlers for autofill (note: item name is readonly here, so only MijnTafelName needs it)
            row.innerHTML = `
                <td><input class="item-name-input wide-input" value="${item.item || ''}" readonly></td>
                <td><input class="mijn-tafel-name-input wide-input" value="${item.mijnTafelName || ''}" oninput="autoFillPurchaseFields(this, 'mijnTafelName')"></td>
                <td><input class="qty-input" type="number" min="1" value="${item.qty || 1}" oninput="updateEditPurchaseRow(this)"></td>
                <td><input class="cost-input" type="number" step="0.01" min="0" value="${item.cost || 0}" oninput="updateEditPurchaseRow(this)"></td>
                <td class="total"><input class="total-input" type="number" step="0.01" min="0" value="0" oninput="updateEditPurchaseRow(this)"></td>
                <td class="discount">${euro.format(item.total || 0)}</td> <td class="net-cost">${euro.format(item.total || 0)}</td> <td><input class="price-input" type="number" step="0.01" min="0" value="${item.price || 0}"></td>
                <td><select class="category-select"></select></td>
                <td><button type="button" onclick="removeEditPurchaseItemRow(this)">Remove</button></td>
            `;
             updateCategoryDropdowns(row.querySelector('.category-select')); // Populate dropdown
             row.querySelector('.category-select').value = item.category || ''; // Set selected category
        });

        updateSupplierDropdowns(); // Ensure supplier dropdown is populated
        document.getElementById('editSupplier').value = firstPurchase.supplier; // Reselect supplier
        updateEditPurchaseTotal(); // Calculate initial totals based on populated rows
        setDateLimits(); // Set max date for date input
        modal.style.display = 'block';
        // Calculate initial Cost (€) for each row in Edit Order modal
        const editRows = document.querySelectorAll('#editItemsBody tr');
        editRows.forEach(row => {
            const qtyInput = row.querySelector('.qty-input');
            const costInput = row.querySelector('.cost-input');
            const totalInput = row.querySelector('.total-input');
            const qty = parseFloat(qtyInput.value) || 0;
            const cost = parseFloat(costInput.value) || 0;
            if (totalInput) {
                totalInput.value = (qty * cost);
            }
        });
        // Update overall totals after initializing row totals
        updateEditPurchaseTotal();
        console.log('Edit purchase modal opened for original indices:', originalIndices);
    } catch (e) {
        console.error('Error in openEditPurchaseModal:', e);
         alert("Could not open edit purchase window.");
    }
}



function updateEditPurchaseRow(inputElement) {
    try {
        const row = inputElement.closest('tr');
        if (!row) return;
        const qtyInput = row.querySelector('.qty-input');
        const costInput = row.querySelector('.cost-input');
        const totalInput = row.querySelector('.total-input');
        const qty = parseFloat(qtyInput.value) || 0;
        let cost = parseFloat(costInput.value) || 0;
        if (inputElement.classList.contains('total-input')) {
            const totalVal = parseFloat(totalInput.value) || 0;
            cost = qty > 0 ? totalVal / qty : 0;
            costInput.value = cost;
        } else {
            const itemTotalCost = qty * cost;
            totalInput.value = itemTotalCost;
        }
        updateEditPurchaseTotal();
    } catch (e) {
        console.error('Error in updateEditPurchaseRow:', e);
    }
}


function removeEditPurchaseItemRow(button) {
     try {
        const row = button.closest('tr');
        if (row) {
            row.remove();
            updateEditPurchaseTotal(); // Recalculate totals after removing row
        }
    } catch (e) {
        console.error('Error in removeEditPurchaseItemRow:', e);
    }
}




function updateEditPurchaseTotal() {
    try {
        const rows = Array.from(document.getElementById('editItemsBody')?.rows || []);
        const orderDiscountInput = document.getElementById('editDiscount');
        const totalCostElement = document.getElementById('editTotalCost');
        const discountTotalSumElement = document.getElementById('editDiscountTotalSum');
        if (!orderDiscountInput || !totalCostElement || !discountTotalSumElement) return;

        const orderDiscount = parseFloat(orderDiscountInput.value) || 0;

        // First pass: compute gross costs and total gross
        let totalGross = 0;
        const grossCosts = [];
        for (let row of rows) {
            const qty = parseFloat(row.querySelector('.qty-input')?.value) || 0;
            const cost = parseFloat(row.querySelector('.cost-input')?.value) || 0;
            const gross = qty * cost;
            grossCosts.push({ gross, qty });
            totalGross += gross;
        }

            // —— LIVE per-row discount & net cost —— 
    rows.forEach((row, idx) => {
      const { gross, qty } = grossCosts[idx];
      const rowDiscount = totalGross > 0
        ? (gross / totalGross) * orderDiscount
        : 0;
      const after    = gross - rowDiscount;
      const netEach  = qty > 0 ? after / qty : 0;
      const discCell = row.querySelector('.discount');
      const netCell  = row.querySelector('.net-cost');
      if (discCell) discCell.textContent = euro.format(after);
      if (netCell)  netCell.textContent  = euro.format(netEach);
    });
    // —— end live row update —— 

       // Apply order-level discount all at once
	const finalTotalCost = Math.max(0, totalGross - orderDiscount);


        // Update overall total
        totalCostElement.textContent = euro.format(finalTotalCost);
        discountTotalSumElement.textContent = euro.format(finalTotalCost);

    } catch (e) {
        console.error('Error in updateEditPurchaseTotal:', e);
    }
}



// MODIFIED: Added oninput handlers for autofill
function addEditItemRow() {
    // Adds a new, empty row to the Edit Purchase modal table
     try {
        const tbody = document.getElementById('editItemsBody');
        if (!tbody) throw new Error('Edit purchase items table body not found');

        const row = tbody.insertRow();
        // Note: New items added during edit should probably NOT be readonly
        row.innerHTML = `
            <td><input class="item-name-input wide-input" placeholder="New Item Name" type="text" list="inventoryItems" oninput="autoFillPurchaseFields(this, 'item'); populatePurchasePrice(this); populatePurchaseCategory(this)"></td>
            <td><input class="mijn-tafel-name-input wide-input" placeholder="Mijn Tafel Name" type="text" list="mijnTafelNames" oninput="autoFillPurchaseFields(this, 'mijnTafelName'); populatePurchasePrice(this); populatePurchaseCategory(this)"></td>
            <td><input class="qty-input" type="number" min="1" value="1" oninput="updateEditPurchaseRow(this)"></td>
            <td><input class="cost-input" type="number" step="0.01" min="0" value="0" oninput="updateEditPurchaseRow(this)"></td>
            <td class="total"><input class="total-input" type="number" step="0.01" min="0" value="0" oninput="updateEditPurchaseRow(this)"></td>
            <td class="discount">€0.00</td>
            <td class="net-cost">€0.00</td>
            <td><input class="price-input" type="number" step="0.01" min="0" value="0"></td>
            <td><select class="category-select"></select></td>
            <td><button type="button" onclick="removeEditPurchaseItemRow(this)">Remove</button></td>
        `;
        updateCategoryDropdowns(row.querySelector('.category-select')); // Populate dropdown for the new row
        updateEditPurchaseTotal(); // Recalculate totals after adding row
    } catch (e) {
        console.error('Error in addEditItemRow:', e);
        alert('Could not add new item row to edit purchase.');
    }
}

// MODIFIED: Added comment for date check
function saveEditedPurchase() {
    try {
        // 1) Get modal & original indices
        const modal = document.getElementById('editPurchaseModal');
        const originalIndices = JSON.parse(modal.dataset.originalIndices || '[]');

        // 2) Read inputs
        const dateInput         = document.getElementById('editDate');
        const supplierInput     = document.getElementById('editSupplier');
        const orderNumberInput  = document.getElementById('editOrderNumber');
        const orderDiscountInput= document.getElementById('editDiscount');
        const rows              = document.getElementById('editItemsBody').rows;

        const dateValue        = dateInput.value;
        const supplier         = supplierInput.value.trim();
        const orderNumber      = orderNumberInput.value.trim();
        const orderDiscount    = parseFloat(orderDiscountInput.value) || 0;

        if (!dateValue || !supplier) {
            alert('Please select a Date and Supplier.');
            return;
        }
        if (rows.length === 0) {
            alert('Purchase must contain at least one item.');
            return;
        }

        // 3) Parse & validate date
        const date = new Date(dateValue);
        if (isNaN(date.getTime())) {
            alert('Invalid date selected.');
            return;
        }
        date.setHours(0,0,0,0);
        const today = new Date(); today.setHours(0,0,0,0);
        if (date > today) {
            alert("Purchase date cannot be in the future.");
            return;
        }
        const formattedDate = formatEuropeanDate(date);

        // 4) Remove original transactions
        originalIndices
          .slice()                            // copy
          .sort((a,b)=>b-a)                   // highest first
          .forEach(idx => {
            if (idx >=0 && idx < transactions.length) {
              transactions.splice(idx,1);
            }
          });

        // 5) Gather & validate new rows, compute totals
        let newItemsData = [];
        let totalCostBeforeDiscount = 0;
        for (let row of rows) {
            const item        = row.querySelector('.item-name-input').value.trim();
            const mijnTafel   = row.querySelector('.mijn-tafel-name-input').value.trim();
            const qty         = parseInt(row.querySelector('.qty-input').value);
            const cost        = parseFloat(row.querySelector('.cost-input').value);
            const price       = parseFloat(row.querySelector('.price-input').value);
            const category    = row.querySelector('.category-select').value;

            if (!item || isNaN(qty) || qty <= 0 || isNaN(cost) || cost < 0 || isNaN(price) || price < 0) {
                alert(`Invalid data in item row: "${item || 'Unnamed Item'}". Check Item Name, Qty (>0), Cost (>=0), Price (>=0).`);
                return;
            }

            const itemTotal = qty * cost;
            totalCostBeforeDiscount += itemTotal;
            newItemsData.push({ item, mijnTafelName: mijnTafel, qty, cost, price, category, itemTotal });
        }

        // 6) Create new transactions with full-precision net costs
        newItemsData.forEach(pItem => {
            const proportion   = totalCostBeforeDiscount > 0
                                ? pItem.itemTotal / totalCostBeforeDiscount
                                : 0;
            const itemDiscount = orderDiscount * proportion;
            const itemNetExact = pItem.itemTotal - itemDiscount;

            transactions.push({
                type:         'purchase',
                item:          pItem.item,
                mijnTafelName: pItem.mijnTafelName,
                qty:           pItem.qty,
                cost:          pItem.cost,
                total:         itemNetExact,
                price:         pItem.price,
                date:          formattedDate,
                supplier,
                orderNumber,
                category:      pItem.category
            });
        });

        // 7) Update UI & storage
        recalculateInventory();
        updateDashboard();
        updateCashFlowTable();
        closeModal('editPurchaseModal');
        // Only if the **All Purchases** modal is open, fully rebuild its table:
        const phModal = document.getElementById('allPurchasesModal');
        if (phModal && phModal.style.display === 'block') {
        updateAllPurchasesTable();
        }

        // — Refresh Item Details modal if open —
        const itemModal = document.getElementById('itemDetailsModal');
        if (itemModal && itemModal.style.display === 'block') {
        const name  = itemModal.dataset.itemName;
        const tafel = itemModal.dataset.mijnTafelName;
        openItemDetailsModal(name, tafel);
        }

        // 8) Compute and show true net total
        const finalNetTotal = totalCostBeforeDiscount - orderDiscount;
        console.log('Purchase edited and saved:', {
          date: formattedDate,
          supplier,
          orderNumber,
          totalCost: finalNetTotal
        });
        alert(`Purchase changes saved successfully. Total: ${euro.format(finalNetTotal)}`);

    } catch (e) {
        console.error('Error in saveEditedPurchase:', e);
        alert('An error occurred while saving the edited purchase.');
    }
}


function deletePurchaseGroup(originalIndices) {
    try {
        // Validate indices array
        if (!Array.isArray(originalIndices) || originalIndices.length === 0) {
             alert("Error: Invalid purchase selection for deletion.");
             console.error("Invalid indices passed to deletePurchaseGroup:", originalIndices);
             return;
        }

        // Get details for confirmation message (optional but good UX)
        const firstIndex = originalIndices[0];
        const firstItem = transactions[firstIndex];
        const details = firstItem ? `Date: ${firstItem.date}, Supplier: ${firstItem.supplier}, Order#: ${firstItem.orderNumber || 'N/A'}` : 'this purchase group';

        if (!confirm(`Are you sure you want to delete ${details}? This will remove all items in this group and cannot be undone.`)) {
            return;
        }

        // Remove original purchase transactions associated with this group
        // Sort indices descending for safe removal
        const indicesToRemove = [...originalIndices].sort((a, b) => b - a);
        let itemsRemoved = 0;
        indicesToRemove.forEach(index => {
            if (index >= 0 && index < transactions.length && transactions[index].type === 'purchase') {
                 transactions.splice(index, 1);
                 itemsRemoved++;
            } else {
                 console.warn(`Attempted to remove transaction at invalid index ${index} or it wasn't a purchase.`);
            }
        });
        console.log(`Deleted ${itemsRemoved} purchase items.`);

        // Recalculate inventory and update UI
        recalculateInventory(); // Calls saveData, updates tables/lists
        updatePurchaseHistoryTable(); // Refresh history table
        updateDashboard();
        updateCashFlowTable();

        alert('Purchase group deleted successfully.');

    } catch (e) {
        console.error('Error in deletePurchaseGroup:', e);
        alert('An error occurred while deleting the purchase group.');
    }
}


// --- Cash Flow ---
function updateCashFlowTable() {
    try {
        const tableBody = document.getElementById('cashFlowBody'); // Corrected ID
        const cashFlowTotalElement = document.getElementById('cashFlowTotal'); // Corrected ID
        if (!tableBody || !cashFlowTotalElement) {
            console.warn('Cash flow table body or total element not found');
            return;
        }
        tableBody.innerHTML = ''; // Clear existing rows

        const monthlyData = {};
        transactions.forEach(t => {
            // Ensure transaction has a valid date
            if (!t.date || !/^\d{2}\/\d{2}\/\d{4}$/.test(t.date)) {
                 console.warn("Skipping transaction with invalid date for cash flow:", t);
                 return;
            }
            try {
                const date = parseEuropeanDate(t.date);
                if (isNaN(date.getTime())) { // Skip if date parsing failed
                     console.warn("Skipping transaction with unparseable date for cash flow:", t);
                    return;
                }
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0'); // 01-12
                const key = `${year}-${month}`; // YYYY-MM format

                if (!monthlyData[key]) {
                    monthlyData[key] = { sales: 0, purchases: 0, monthDate: new Date(year, month - 1) };
                }

                // Add to totals, ensuring value is a number
                if (t.type === 'sale') {
                    monthlyData[key].sales += Number(t.total) || 0;
                } else if (t.type === 'purchase') {
                    monthlyData[key].purchases += Number(t.total) || 0;
                }
            } catch (e) {
                 console.error("Error processing transaction for cash flow:", t, e);
            }
        });

        let totalNet = 0;
        // Sort months descending (YYYY-MM format sorts correctly)
        const sortedMonths = Object.keys(monthlyData).sort().reverse();

        if (sortedMonths.length === 0) {
             tableBody.innerHTML = '<tr><td colspan="5" style="text-align: center;">No transactions recorded</td></tr>';
        } else {
            sortedMonths.forEach(key => {
                const data = monthlyData[key];
                const net = data.sales - data.purchases;
                totalNet += net;
                const netClass = net >= 0 ? 'positive' : 'negative';
                // Display full month name and year
                const monthName = data.monthDate.toLocaleString('en', { month: 'long', year: 'numeric' });

                const row = tableBody.insertRow();
                row.innerHTML = `
                    <td>${monthName}</td>
                    <td>${euro.format(data.sales)}</td>
                    <td>${euro.format(data.purchases)}</td>
                    <td class="${netClass}">${euro.format(net)}</td>
                    <td><button onclick="openCashFlowDetailsModal('${key}')">Details</button></td>
                `;
            });
        }
        cashFlowTotalElement.textContent = euro.format(totalNet);
        cashFlowTotalElement.className = totalNet >= 0 ? 'positive' : 'negative'; // Style total as well
        console.log('Cash Flow table updated');
    } catch (e) {
        console.error('Error in updateCashFlowTable:', e);
         const tableBody = document.getElementById('cashFlowBody');
         if(tableBody) tableBody.innerHTML = '<tr><td colspan="5" class="text-center text-red-400 py-4">Error loading cash flow</td></tr>';
    }
}

function openCashFlowDetailsModal(monthKey) { // monthKey is YYYY-MM
    try {
        const modal = document.getElementById('cashFlowDetailsModal');
        if (!modal) throw new Error('Cash flow details modal element not found');

        const [year, month] = monthKey.split('-');
        const titleElement = document.getElementById('cashFlowDetailsTitle');
        const tableBody = document.getElementById('cashFlowDetailsBody'); // Corrected ID
        const totalSalesLabel = document.getElementById('totalSalesSumLabel');
        const totalPurchasesLabel = document.getElementById('totalPurchasesSumLabel');

        if (!titleElement || !tableBody || !totalSalesLabel || !totalPurchasesLabel) {
             console.warn("Missing elements within cash flow details modal.");
             return;
        }

        // Set title to Month Year
        const monthDate = new Date(year, parseInt(month) - 1);
        titleElement.textContent = monthDate.toLocaleString('en', { month: 'long', year: 'numeric' });

        tableBody.innerHTML = ''; // Clear previous details
        const dailyData = {};
        let monthTotalSales = 0;
        let monthTotalPurchases = 0;

        transactions
            .filter(t => t.date && t.date.endsWith(`/${month}/${year}`)) // Filter by MM/YYYY
            .forEach(t => {
                if (!dailyData[t.date]) {
                    dailyData[t.date] = { sales: 0, purchases: 0, dateObj: parseEuropeanDate(t.date) };
                }
                const dailyTotal = Number(t.total) || 0;
                if (t.type === 'sale') {
                    dailyData[t.date].sales += dailyTotal;
                    monthTotalSales += dailyTotal;
                } else if (t.type === 'purchase') {
                    dailyData[t.date].purchases += dailyTotal;
                    monthTotalPurchases += dailyTotal;
                }
            });

        // Sort daily data by date ascending
        const sortedDates = Object.keys(dailyData).sort((a, b) => {
            const dateA = dailyData[a].dateObj;
            const dateB = dailyData[b].dateObj;
            if (isNaN(dateA.getTime()) && isNaN(dateB.getTime())) return 0;
            if (isNaN(dateA.getTime())) return 1;
            if (isNaN(dateB.getTime())) return -1;
            return dateA - dateB;
        });

        if (sortedDates.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="4" style="text-align: center;">No transactions for this month</td></tr>';
        } else {
            sortedDates.forEach(dateKey => {
                const data = dailyData[dateKey];
                const net = data.sales - data.purchases;
                const row = tableBody.insertRow();
                row.innerHTML = `
                    <td>${dateKey}</td>
                    <td>${euro.format(data.sales)}</td>
                    <td>${euro.format(data.purchases)}</td>
                    <td class="${net >= 0 ? 'positive' : 'negative'}">${euro.format(net)}</td>
                `;
            });
        }

        // Update total labels
        totalSalesLabel.textContent = `Total Sales: ${euro.format(monthTotalSales)}`;
        totalPurchasesLabel.textContent = `Total Purchases: ${euro.format(monthTotalPurchases)}`;

        modal.style.display = 'block';
        console.log('Cash flow details modal opened for:', monthKey);
    } catch (e) {
        console.error('Error in openCashFlowDetailsModal:', e);
        alert('Could not open cash flow details.');
    }
}

// --- Reports ---
function showMarginReport() {
    try {
        const tableBody = document.getElementById('reportBody'); // Corrected ID
        if (!tableBody) throw new Error('Report table body element not found');
        tableBody.innerHTML = ''; // Clear only tbody

        const itemData = {};
        // Aggregate revenue and cost per item
        transactions.forEach(t => {
            if (!t.item) return; // Skip transactions without an item name
            if (!itemData[t.item]) {
                itemData[t.item] = { revenue: 0, cost: 0, soldQty: 0, purchasedQty: 0 };
            }
            const total = Number(t.total) || 0;
            const qty = Number(t.qty) || 0;

            if (t.type === 'sale') {
                itemData[t.item].revenue += total;
                itemData[t.item].soldQty += qty;
            } else if (t.type === 'purchase') {
                // Cost for margin should be based on the cost of goods *sold*
                // This simple aggregation uses total purchase cost, which isn't true COGS
                // For a more accurate report, COGS needs calculation (e.g., FIFO/LIFO/Average)
                // Using total purchase cost as a proxy for now.
                 itemData[t.item].cost += total; // Using net purchase cost as proxy
                 itemData[t.item].purchasedQty += qty;
            }
        });

        // TODO: Implement actual COGS calculation for better accuracy if needed.
        // Example: Average Cost Method
        // For each item sold: cost = soldQty * (totalPurchaseCost / totalPurchasedQty)

        const sortedItems = Object.keys(itemData).sort((a, b) => a.localeCompare(b)); // Sort items alphabetically

        if (sortedItems.length === 0) {
             tableBody.innerHTML = '<tr><td colspan="5" style="text-align: center;">No data available for report</td></tr>';
             return;
        }

        sortedItems.forEach(item => {
            const data = itemData[item];
            const revenue = data.revenue;
            // Using total purchase cost as COGS proxy here
            const cost = data.cost;
            const margin = revenue - cost;
            // Calculate margin % based on revenue. Handle division by zero.
            const marginPercent = revenue !== 0 ? ((margin / revenue) * 100) : 0;

            const row = tableBody.insertRow(); // Insert into tbody
            row.innerHTML = `
                <td>${item}</td>
                <td>${euro.format(revenue)}</td>
                <td>${euro.format(cost)}</td>
                <td class="${margin >= 0 ? 'positive' : 'negative'}">${euro.format(margin)}</td>
                <td>${marginPercent}%</td>
            `;
        });
        console.log("Margin report generated.");
    } catch (e) {
        console.error('Error in showMarginReport:', e);
         const tableBody = document.getElementById('reportBody');
         if(tableBody) tableBody.innerHTML = '<tr><td colspan="5" class="text-center text-red-400 py-4">Error generating margin report</td></tr>';
    }
}

// --- Inventory Tables ---

// Get the category for an item based on latest purchase
function getCategoryForItem(item) {
    const tx = transactions
        .filter(t => t.type === 'purchase' && t.item === item && t.category)
        .sort((a, b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date))[0];
    return tx ? tx.category : '';
}

function updateInventoryTable() {
    try {
        const inventoryTableBody = document.getElementById('inventoryBody');
        const soldOutTableBody = document.getElementById('soldOutBody');
        if (!inventoryTableBody || !soldOutTableBody) {
            console.warn('Inventory or Sold Out table body not found');
            return;
        }
        inventoryTableBody.innerHTML = '';
        soldOutTableBody.innerHTML = '';
        // Populate In Stock table
        let hasInventory = false;
        const sortedInventoryItems = Object.keys(inventory).sort((a,b)=>a.localeCompare(b));
        sortedInventoryItems.forEach(item => {
            const currentQty = inventory[item] || 0;
            if (currentQty > 0) {
                const relevantPurchases = transactions.filter(t => t.type === 'purchase' && t.item === item && t.mijnTafelName)
                    .sort((a,b)=>parseEuropeanDate(b.date)-parseEuropeanDate(a.date));
                const mijnName = relevantPurchases.length ? relevantPurchases[0].mijnTafelName : '';
                const row = inventoryTableBody.insertRow();
                row.innerHTML = `
                    <td>
                    <a href="javascript:"
                        onclick="openItemDetailsModal(
                            '${item.replace(/'/g,"\\'")}',
                            '${mijnName.replace(/'/g,"\\'")}'
                        )">
                        ${item}
                    </a>
                    </td>
                    <td>${mijnName}</td>
                    <td>${currentQty}</td>
                    <td>${getPurchasedQuantity(item) || 0}</td>
                    <td>${getSoldQuantity(item) || 0}</td>
                    <td>${getWrittenOffQuantity(item) || 0}</td>
                    <td>${getCategoryForItem(item)}</td>
                    <td>${getCategoryForItem(item)}</td>
                `;
                hasInventory = true;
            }
        });
        if (!hasInventory) {
            inventoryTableBody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No items currently in stock</td></tr>';
        }
        // Populate Sold Out table
        let hasSoldOut = false;
        const itemsToDisplay = soldOutSortColumn ? getSortedSoldOutItems() : Object.keys(soldOutItems).sort((a,b)=>a.localeCompare(b));
        itemsToDisplay.forEach(itemInfo => {
            const itemName = typeof itemInfo === 'object' ? itemInfo.item : itemInfo;
            const purchasedQty = getPurchasedQuantity(itemName) || 0;
            const soldQty = getSoldQuantity(itemName) || 0;
            const writtenOffQty = getWrittenOffQuantity(itemName) || 0;
            if (purchasedQty > 0) {
                const relevantPurchasesSO = transactions.filter(t => t.type === 'purchase' && t.item === itemName && t.mijnTafelName)
                    .sort((a,b)=>parseEuropeanDate(b.date)-parseEuropeanDate(a.date));
                const mijnNameSO = relevantPurchasesSO.length ? relevantPurchasesSO[0].mijnTafelName : '';
                const row = soldOutTableBody.insertRow();
                row.innerHTML = `
                    <td>
                    <a href="javascript:"
                        onclick="openItemDetailsModal(
                            '${itemName.replace(/'/g,"\\'")}',
                            '${mijnNameSO.replace(/'/g,"\\'")}'
                        )">
                        ${itemName}
                    </a>
                    </td>
                    <td>${mijnNameSO}</td>
                    <td>0</td>
                    <td>${purchasedQty}</td>
                    <td>${soldQty}</td>
                    <td>${writtenOffQty}</td>
                    <td>${getCategoryForItem(itemName)}</td>
                    <td>${getCategoryForItem(itemName)}</td>
                `;
                hasSoldOut = true;
            }
        });
        if (!hasSoldOut) {
            soldOutTableBody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No sold out items</td></tr>';
        }
        console.log('Inventory & Sold Out tables updated');
    } catch (e) {
        console.error('Error in updateInventoryTable:', e);
        const inventoryTableBody = document.getElementById('inventoryBody');
        const soldOutTableBody = document.getElementById('soldOutBody');
        if (inventoryTableBody) inventoryTableBody.innerHTML = '<tr><td colspan="6" class="text-center text-red-400 py-4">Error loading inventory</td></tr>';
        if (soldOutTableBody) soldOutTableBody.innerHTML = '<tr><td colspan="6" class="text-center text-red-400 py-4">Error loading sold out items</td></tr>';
    }
}


function getSortedSoldOutItems() {
     // Returns an array of {item, purchasedQty, soldQty, writtenOffQty} objects, sorted
     const items = Object.keys(soldOutItems).map(item => ({
        item,
        purchasedQty: getPurchasedQuantity(item) || 0,
        soldQty: getSoldQuantity(item) || 0,
        writtenOffQty: getWrittenOffQuantity(item) || 0
    }));

    if (soldOutSortColumn) {
         items.sort((a, b) => {
            const valueA = a[soldOutSortColumn];
            const valueB = b[soldOutSortColumn];
            // Simple numeric comparison
            const comparison = valueA - valueB;
            return soldOutSortDirection === 'asc' ? comparison : -comparison;
        });
    } else {
         items.sort((a, b) => a.item.localeCompare(b.item)); // Default sort by item name alpha
    }
    return items;
}

function sortSoldOutTable(column) {
    try {
        const headerCell = document.querySelector(`#soldOutTable th[onclick*="'${column}'"]`);
        if (!headerCell) return;

        // Reset icons on other sortable headers
        document.querySelectorAll('#soldOutTable th.sortable i').forEach(icon => {
            icon.className = 'fas fa-sort opacity-50 ml-1'; // Reset to default sort icon
        });

        // Determine new sort direction
        if (soldOutSortColumn === column) {
            soldOutSortDirection = soldOutSortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            soldOutSortColumn = column;
            soldOutSortDirection = 'asc'; // Default to ascending on new column
        }

        // Update icon on the clicked header
        const icon = headerCell.querySelector('i');
        if (icon) {
            icon.className = `fas fa-sort-${soldOutSortDirection === 'asc' ? 'up' : 'down'} ml-1`; // Set up/down icon
            icon.classList.remove('opacity-50'); // Make icon fully visible
        }

        updateInventoryTable(); // Re-render the table which will use the new sort order via getSortedSoldOutItems
        console.log(`Sold Out table sorted by ${column} (${soldOutSortDirection})`);
    } catch (e) {
        console.error('Error in sortSoldOutTable:', e);
    }
}

// --- Write-Off Handling ---
function openWriteOffModal() {
    try {
        const modal = document.getElementById('writeOffModal');
        if (!modal) throw new Error('Write-off modal element not found');
        // Reset fields
        document.getElementById('writeOffItem').value = '';
        document.getElementById('writeOffQty').value = '';
        document.getElementById('writeOffDate').value = getTodayStrLocal();
        document.getElementById('writeOffComment').value = '';

        updateWriteOffHistoryTable(); // Show current history
        updateSaleItemList(); // Ensure item datalist is up-to-date
        setDateLimits(); // Set max date

        modal.style.display = 'block';
        console.log("Write-off modal opened.");
    } catch (e) {
        console.error('Error in openWriteOffModal:', e);
        alert("Could not open write-off window.");
    }
}

function addWriteOff() {
    try {
        const itemInput = document.getElementById('writeOffItem');
        const qtyInput = document.getElementById('writeOffQty');
        const dateInput = document.getElementById('writeOffDate');
        const commentInput = document.getElementById('writeOffComment');

        const item = itemInput.value.trim();
        const qty = parseInt(qtyInput.value);
        const dateValue = dateInput.value; // YYYY-MM-DD
        const comment = commentInput.value.trim();

        if (!item || isNaN(qty) || qty <= 0 || !dateValue) {
            alert('Please fill Item Name, Quantity (>0), and Date correctly.');
            return;
        }

        // Check inventory availability
        if (!inventory[item] || inventory[item] < qty) {
            alert(`Not enough inventory for "${item}" to write off. Available: ${inventory[item] || 0}`);
            return;
        }

        const date = new Date(dateValue);
        if (isNaN(date.getTime())) {
            alert('Invalid date selected.');
            return;
        }
        const formattedDate = formatEuropeanDate(date); // Convert to DD/MM/YYYY

        // Check if date is in the future
        const today = new Date(); today.setHours(0,0,0,0);
        today.setHours(0, 0, 0, 0);
	date.setHours(0, 0, 0, 0);
        if (date.getTime() > today.getTime()) { // today allowed
            alert("Write-off date cannot be in the future.");
            return;
        }

        // Calculate cost of written-off items (e.g., using average cost or latest cost)
        // Using latest purchase cost as a simple proxy:
        const purchases = transactions.filter(t => t.type === 'purchase' && t.item === item);
        purchases.sort((a, b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date)); // Sort descending
        const latestPurchaseCostPerItem = purchases.length > 0 ? (purchases[0].cost || 0) : 0;
        const writeOffCost = qty * latestPurchaseCostPerItem;

        // Add to writeOffs array
        writeOffs.push({
            item,
            qty,
            cost: writeOffCost, // Store calculated cost
            date: formattedDate,
            comment: comment || '' // Store comment or empty string
        });

        recalculateInventory(); // Updates inventory, calls saveData, updates tables
        updateWriteOffHistoryTable(); // Refresh history table in the modal

        // Clear input fields
        itemInput.value = '';
        qtyInput.value = '';
        dateInput.value = getTodayStrLocal(); // Reset date to today
        commentInput.value = '';

        console.log('Write-off added:', { item, qty, cost: writeOffCost, date: formattedDate, comment });
        // No alert needed, table update provides feedback
    } catch (e) {
        console.error('Error in addWriteOff:', e);
        alert('An error occurred while adding the write-off.');
    }
}

function updateWriteOffHistoryTable() {
    try {
        const tableBody = document.getElementById('writeOffHistoryBody'); // Corrected ID
        if (!tableBody) {
            console.warn('Write-off history table body not found');
            return;
        }
        tableBody.innerHTML = ''; // Clear existing rows

        if (writeOffs.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No write-offs recorded</td></tr>';
        } else {
            // Sort write-offs by date descending before displaying
            const sortedWriteOffs = [...writeOffs].sort((a, b) => {
                 const dateA = parseEuropeanDate(a.date);
                 const dateB = parseEuropeanDate(b.date);
                 if (isNaN(dateA.getTime()) && isNaN(dateB.getTime())) return 0;
                 if (isNaN(dateA.getTime())) return 1;
                 if (isNaN(dateB.getTime())) return -1;
                 return dateB - dateA; // Descending sort
            });


            sortedWriteOffs.forEach((writeOff, index) => {
                 // Find original index for deletion
                 const originalIndex = writeOffs.findIndex(wo => wo === writeOff);

                const row = tableBody.insertRow();
                row.innerHTML = `
                    <td>${writeOff.date || 'N/A'}</td>
                    <td>${writeOff.item || 'N/A'}</td>
                    <td>${writeOff.qty || 0}</td>
                    <td>${euro.format(writeOff.cost || 0)}</td>
                    <td>${writeOff.comment || ''}</td>
                    <td><button onclick="deleteWriteOff(${originalIndex})">Delete</button></td>
                `;
            });
        }
        console.log("Write-off history table updated.");
    } catch (e) {
        console.error('Error in updateWriteOffHistoryTable:', e);
         const tableBody = document.getElementById('writeOffHistoryBody');
         if(tableBody) tableBody.innerHTML = '<tr><td colspan="6" class="text-center text-red-400 py-4">Error loading write-off history</td></tr>';
    }
}

function deleteWriteOff(originalIndex) {
    try {
         // Validate index
        if (originalIndex < 0 || originalIndex >= writeOffs.length) {
            alert("Error: Invalid write-off reference.");
            console.error("Invalid index passed to deleteWriteOff:", originalIndex);
            return;
        }

        const writeOffToDelete = writeOffs[originalIndex];
        if (!confirm(`Are you sure you want to delete this write-off?\n\nDate: ${writeOffToDelete.date}\nItem: ${writeOffToDelete.item}\nQty: ${writeOffToDelete.qty}`)) return;

        writeOffs.splice(originalIndex, 1); // Remove from array
        recalculateInventory(); // Updates inventory, calls saveData, updates tables
        updateWriteOffHistoryTable(); // Refresh history table in the modal
        console.log('Write-off deleted:', writeOffToDelete);
        // No alert needed, table update provides feedback
    } catch (e) {
        console.error('Error in deleteWriteOff:', e);
        alert('An error occurred while deleting the write-off.');
    }
}

// --- Data Lists and Input Validation ---
function updateSaleItemList() {
    // Updates the datalist for item inputs based on current inventory
    try {
        const datalist = document.getElementById('inventoryItems');
        if (!datalist) {
            console.warn('Inventory items datalist element not found');
            return;
        }
        datalist.innerHTML = ''; // Clear existing options
        // Get items currently in stock and sort them
        const itemsInStock = Object.keys(inventory).filter(item => inventory[item] > 0).sort((a, b) => a.localeCompare(b));

        itemsInStock.forEach(item => {
            const option = document.createElement('option');
            option.value = item;
            // Optionally add text content if needed: option.textContent = item;
            datalist.appendChild(option);
        });
    } catch (e) {
        console.error('Error in updateSaleItemList:', e);
    }
}

function updateMijnTafelNameList() {
    // Updates the datalist for Mijn Tafel Name inputs based on purchase history
    try {
        const datalist = document.getElementById('mijnTafelNames');
        if (!datalist) {
            console.warn('Mijn Tafel Names datalist element not found');
            return;
        }
        datalist.innerHTML = ''; // Clear existing options
        const mijnTafelNames = new Set();
        // Collect unique, non-empty Mijn Tafel Names from purchase transactions
        transactions
            .filter(t => t.type === 'purchase' && t.mijnTafelName) // Filter for purchases with a name
            .forEach(t => mijnTafelNames.add(t.mijnTafelName));

        // Sort names alphabetically and add as options
        [...mijnTafelNames].sort((a, b) => a.localeCompare(b)).forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            datalist.appendChild(option);
        });
    } catch (e) {
        console.error('Error in updateMijnTafelNameList:', e);
    }
}

function checkSaleItemValidity() {
    // Disables the "Record Sale" button if the selected item is invalid or out of stock
    try {
        const itemInput = document.getElementById('saleItem');
        const recordButton = document.getElementById('recordSaleBtn');

        if (!itemInput || !recordButton) {
             console.warn("Sale item input or record button not found for validity check.");
            return;
        }

        const item = itemInput.value.trim();
        // Disable if item is empty OR item is not in inventory OR item quantity is 0 or less
        const isDisabled = !item || !inventory.hasOwnProperty(item) || inventory[item] <= 0;

        recordButton.disabled = isDisabled;
        // Optional: Add visual feedback like changing border color
        // itemInput.style.borderColor = isDisabled && item ? 'red' : ''; // Red border if item exists but is unavailable

    } catch (e) {
        console.error('Error in checkSaleItemValidity:', e);
    }
}

// --- Data Import/Export ---
function exportSalesData() {
    try {
        const sales = transactions.filter(t => t.type === 'sale');
        if (sales.length === 0) {
            alert('No sales data to export.');
            return;
        }

        // Prepare data for sheet, ensuring consistent headers
        const data = sales.map(t => ({
            Date: t.date || '', // DD/MM/YYYY format
            Item: t.item || '',
            MijnTafelName: t.mijnTafelName || '',
            Qty: t.qty || 0,
            Price: t.price || 0, // Price per item
            Total: t.total || 0, // Total for the line (qty * price)
            TablePlace: t.tablePlace || ''
        }));

        // Create worksheet and workbook
        const ws = XLSX.utils.json_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Sales'); // Sheet name

        // Generate filename with date
        const dateStr = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
        const filename = `shop_tracker_sales_${dateStr}.xlsx`; // Use .xlsx extension

        // Trigger download
        XLSX.writeFile(wb, filename);

        console.log('Sales data exported:', sales.length, 'records');
        alert(`Sales data exported successfully as ${filename}`);
    } catch (e) {
        console.error('Error exporting sales data:', e);
        alert('An error occurred while exporting sales data.');
    }
}

function generateUniqueId() {
    return 'id-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
}

function importSalesData(file) {
    try {
        if (!file) {
            alert('No file selected for import.');
            return;
        }
        if (!file.name.match(/\.(xls|xlsx)$/i)) {
            alert('Invalid file type. Please select an Excel file (.xls or .xlsx).');
            return;
        }

        console.log('Starting file import:', file.name, file.size, 'bytes');
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                console.log('FileReader onload triggered');
                const fileData = e.target.result;
                console.log('File data read, length:', fileData.byteLength);
                const workbook = XLSX.read(fileData, { type: 'array', cellDates: true });
                console.log('Workbook read, sheets:', workbook.SheetNames);
                if (!workbook.SheetNames.length) {
                    alert('No sheets found in the Excel file.');
                    return;
                }
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                console.log('Processing sheet:', firstSheetName);
                const json = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: "" });
                console.log('Sheet converted to JSON, rows:', json.length);
                console.log('JSON data:', JSON.stringify(json, null, 2));

                if (json.length === 0) {
                    alert('The selected Excel file is empty or has no data in the first sheet.');
                    return;
                }

                const expectedColumns = ['Date', 'Item', 'MijnTafelName', 'Qty', 'Price', 'TablePlace'];
                const headers = Object.keys(json[0] || {});
                console.log('Headers found:', headers);
                const missingColumns = expectedColumns.filter(col => !headers.includes(col));
                if (missingColumns.length > 0) {
                    alert('Invalid file format. Missing required columns: ' + missingColumns.join(', '));
                    return;
                }

                let newTransactions = [];
                let validationErrors = [];
                const today = new Date(); today.setHours(0,0,0,0);
                today.setHours(0, 0, 0, 0);

                json.forEach((row, index) => {
                    const rowIndex = index + 2;
                    if (!row || typeof row !== 'object') {
                        validationErrors.push(`Row ${rowIndex}: Invalid row data.`);
                        return;
                    }
                    console.log(`Processing row ${rowIndex}:`, row);
                    let rowIsValid = true;

                    const item = String(row.Item || '').trim();
                    const mijnTafelName = String(row.MijnTafelName || '').trim();
                    const qty = parseInt(row.Qty);
                    const price = parseFloat(row.Price);
                    const tablePlace = String(row.TablePlace || '').trim();
                    let dateStr = '';
                    let parsedDate = null;

                    if (!row.Date) {
                        validationErrors.push(`Row ${rowIndex}: Date is missing.`);
                        rowIsValid = false;
                    } else {
                        console.log(`Row ${rowIndex}: Date value = "${row.Date}", type = ${typeof row.Date}`);
                        if (row.Date instanceof Date && !isNaN(row.Date)) {
                            parsedDate = row.Date;
                            parsedDate.setHours(0, 0, 0, 0);
                            dateStr = formatEuropeanDate(parsedDate);
                            console.log(`Row ${rowIndex}: Date is Date object, formatted to "${dateStr}"`);
                        } else {
                            try {
   	 parsedDate = parseEuropeanDate(String(row.Date));
 	   if (isNaN(parsedDate.getTime())) throw new Error('Invalid date');
 	   parsedDate.setHours(0, 0, 0, 0);
  	  dateStr = formatEuropeanDate(parsedDate);
   	 console.log(`Row ${rowIndex}: Parsed string date "${row.Date}" to "${dateStr}"`);
} catch (dateError) {
    	validationErrors.push(`Row ${rowIndex}: Invalid or unrecognized date format "${row.Date}". Use DD/MM/YYYY, YYYY-MM-DD, or MM/DD/YY.`);
   	 console.error(`Row ${rowIndex}: Date parse error:`, dateError);
  	  rowIsValid = false;
	}

                        }
                    }

                    if (parsedDate && parsedDate > today) {
                        validationErrors.push(`Row ${rowIndex}: Date "${dateStr}" cannot be in the future.`);
                        rowIsValid = false;
                    }

                    if (!item) {
                        validationErrors.push(`Row ${rowIndex}: Item is missing or empty.`);
                        rowIsValid = false;
                    }
                    if (!mijnTafelName) {
                        validationErrors.push(`Row ${rowIndex}: MijnTafelName is missing or empty.`);
                        rowIsValid = false;
                    }
                    if (isNaN(qty) || qty <= 0) {
                        validationErrors.push(`Row ${rowIndex}: Qty must be a positive number.`);
                        rowIsValid = false;
                    }
                    if (isNaN(price) || price < 0) {
                        validationErrors.push(`Row ${rowIndex}: Price must be a non-negative number.`);
                        rowIsValid = false;
                    }
			
			if (rowIsValid) {
    			const availableQty = inventory[item] || 0;
    			if (qty > availableQty) {
     			validationErrors.push(`Row ${rowIndex}: Not enough inventory for "${item}". Available: ${availableQty}, requested: ${qty}`);
      			rowIsValid = false;
   				 }
			}
                    if (rowIsValid) {
                        const newSale = {
                            type: 'sale',
                            date: dateStr,
                            item: item,
                            mijnTafelName: mijnTafelName,
                            qty: qty,
                            price: price,
				total: qty * price, // Calculate Total as Price * Qty
                            tablePlace: tablePlace,
                            id: generateUniqueId()
                        };
                        newTransactions.push(newSale);
                        console.log(`Row ${rowIndex}: Added transaction:`, newSale);
                    }
                });

                if (validationErrors.length > 0) {
                    const errorLimit = 10;
                    const errorMessage = "Import failed due to errors:\n\n" +
                                         validationErrors.slice(0, errorLimit).join('\n') +
                                         (validationErrors.length > errorLimit ? `\n...and ${validationErrors.length - errorLimit} more errors.` : '');
                    alert(errorMessage);
                    console.error('Import validation errors:', validationErrors);
                    return;
                }

                if (newTransactions.length > 0) {
                    transactions.push(...newTransactions);
                    localStorage.setItem('transactions', JSON.stringify(transactions));
                    recalculateInventory();
                    updateSalesHistoryTable();
                    updateCashFlowTable();
                    updateDashboard();
                    alert(`Sales data imported successfully: ${newTransactions.length} records added.`);
                    console.log('Sales data imported:', newTransactions.length, 'records');
                } else {
                    alert('No valid sales records found to import.');
                }

            } catch (parseError) {
                console.error('Error parsing or processing Excel file:', parseError);
                alert('Error reading or processing the Excel file. Ensure it is a valid .xls or .xlsx file and the format is correct.');
            } finally {
                document.getElementById('importSalesFile').value = '';
            }
        };
        reader.onerror = function(err) {
            console.error('FileReader error:', err);
            alert('Error reading the selected file.');
            document.getElementById('importSalesFile').value = '';
        };
        reader.readAsArrayBuffer(file);
    } catch (e) {
        console.error('Error setting up importSalesData:', e);
        alert('An error occurred while initiating the sales data import.');
        document.getElementById('importSalesFile').value = '';
    }
}

// --- Initialization ---
function initializeUI() {
    try {
        console.log("Initializing UI...");
        updateDashboard();
        updateSalesHistoryTable();
        updatePurchaseHistoryTable();
        updateCashFlowTable();
        updateInventoryTable();
        updateSupplierDropdowns();
        updateCategoryDropdowns();
        setDateLimits();
        const saleItemInput = document.getElementById('saleItem');
        if (saleItemInput) {
            saleItemInput.removeEventListener('input', checkSaleItemValidity);
            saleItemInput.addEventListener('input', checkSaleItemValidity);
        }
        const monthSelector = document.getElementById('monthSelector');
        if (monthSelector) {
            monthSelector.removeEventListener('change', updateMonthlySalesTable);
            monthSelector.addEventListener('change', updateMonthlySalesTable);
        }
        checkSaleItemValidity();
        // Debug: Log max attributes of all date inputs after full initialization
        setTimeout(() => {
            const dateInputs = document.querySelectorAll('input[type="date"]');
            dateInputs.forEach(input => {
                console.log(`initializeUI: Date input #${input.id || 'unnamed'}: max="${input.max}" after full init`);
            });
        }, 100); // Delay to catch late DOM changes
        console.log('UI Initialized/Refreshed.');
    } catch (e) {
        console.error('Error during UI initialization/refresh:', e);
        alert('An error occurred while initializing the application interface.');
    }
}

function monitorDateInputs() {
    try {
        const today = getTodayStrLocal();
        const dateInputs = document.querySelectorAll('input[type="date"]');
        
        dateInputs.forEach(input => {
            // Skip Rental Period Start and Rental Period End fields
            if (input.id === 'rentalPeriodStart' || input.id === 'rentalPeriodEnd' || input.id === 'editRentalPeriodEnd' || input.id === 'editRentalPeriodStart') {
                return; // Skip these fields
            }

            // If the max attribute is not set to today's date, correct it
            if (input.max !== today) {
                console.warn(`monitorDateInputs: Correcting max attribute for #${input.id || 'unnamed'} from "${input.max}" to "${today}"`);
                input.max = today;
            }
        });

        // Run periodically to catch dynamic changes
        setTimeout(monitorDateInputs, 1000); // Check every second
    } catch (e) {
        console.error('Error in monitorDateInputs:', e);
    }
}



function initializeApp() {
  try {
    console.log("Loading data...");
    loadData().then(() => {
      console.log("Initializing UI...");  
      initializeUI();
      monitorDateInputs();
      loadRentalPayments(); // ✅ This line is crucial!
      console.log('Application initialized successfully.');
    });
  } catch (e) {
    console.error('Critical error during application initialization:', e);
    document.body.innerHTML = `<div style="padding: 20px; text-align: center; color: red; font-family: Arial, sans-serif;">
        <h1>Application Error</h1>
        <p>A critical error occurred during startup. Please check the browser console (F12) for details.</p>
        <p>You might need to clear application data (localStorage) or contact support.</p>
        <pre style="text-align: left; background-color: #f0f0f0; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap;">${e.stack || e.message}</pre>
    </div>`;
  }
}






// --- Global Event Listeners ---
document.addEventListener('DOMContentLoaded', initializeApp); // Use initializeApp as the main entry point

// Add listener for closing modals with Escape key (optional but good UX)
document.addEventListener('keydown', function(event) {
    if (event.key === "Escape") {
        // Find any open modals and close them
        const openModals = document.querySelectorAll('.modal[style*="display: block"]');
        openModals.forEach(modal => {
            closeModal(modal.id); // Use the generic closeModal function
        });
    }
});

</script>


<!-- Modal for viewing all purchases by month -->
<div id="allPurchasesModal" class="modal">
  <div class="modal-content">
    <h3>Purchase History</h3>
    <label for="allPurchasesMonthSelector">Month:</label>
    <select id="allPurchasesMonthSelector" style="margin-bottom:10px;"></select>
    <table id="allPurchasesTable">
      <thead>
        <tr>
          <th>Date</th><th>Supplier</th><th>Order Number</th><th>Cost Before Discount (€)</th><th>Discount (€)</th><th>Total Cost (€)</th>
        
          <th>Actions</th></tr>
      </thead>
      <tbody id="allPurchasesBody"></tbody>
      <tfoot>
        <tr>
          <td colspan="5" style="text-align:right;font-weight:bold;">Total:</td>
          <td id="allPurchasesTotalSum">€0.00</td>
        </tr>
      </tfoot>
    </table>
    <button onclick="closeAllPurchasesModal()">Close</button>
  </div>
</div>
<script>
(function(){
  const monthSel = document.getElementById('allPurchasesMonthSelector');
  function populateMonths(){
    monthSel.innerHTML = '';
    const months = [...new Set(transactions.filter(t=>t.type==='purchase').map(t=>{
      const [d,m,y]=t.date.split('/');
      return `${y}-${m}`;
    }))].sort();
    months.forEach(mon=>{
      const [y,m]=mon.split('-');
      const opt=document.createElement('option');
      opt.value=mon;
      opt.textContent=new Date(y,parseInt(m)-1).toLocaleString('en',{month:'long',year:'numeric'});
      monthSel.appendChild(opt);
    });
  }
  function updateModal(){
    const mon=monthSel.value;
    const body=document.getElementById('allPurchasesBody');
    body.innerHTML='';
    let sum=0;
    transactions.filter(t=>t.type==='purchase').filter(t=>{
      const [d,m,y]=t.date.split('/');
      return `${y}-${m}`===mon;
    }).sort((a,b)=>parseEuropeanDate(b.date)-parseEuropeanDate(a.date))
    .forEach(p=>{
      const before=(p.qty||0)*(p.cost||0);
      const discount=Math.max(0,before-(p.total||0));
      sum+=p.total||0;
      const row=body.insertRow();
      row.innerHTML=`
        <td>${p.date}</td><td>${p.supplier}</td><td>${p.orderNumber||''}</td>
        <td>${euro.format(before)}</td><td>${euro.format(discount)}</td><td>${euro.format(p.total||0)}</td>`;
    });
    document.getElementById('allPurchasesTotalSum').textContent=euro.format(sum);
  }
  window.openAllPurchasesModal=function(){
    populateMonths();
    if(monthSel.options.length) monthSel.value=monthSel.options[monthSel.options.length-1].value;
    updateModal();
    document.getElementById('allPurchasesModal').style.display='block';
  };
  window.closeAllPurchasesModal=function(){
    document.getElementById('allPurchasesModal').style.display='none';
  };
  monthSel.addEventListener('change', updateModal);
})();
</script>


<!-- Modal for viewing all purchases by month -->
<div id="allPurchasesModal" class="modal" style="display:none;">
  <div class="modal-content">
    <h3>Purchase History</h3>
    <label for="allPurchasesMonthSelector">Month:</label>
    <select id="allPurchasesMonthSelector" style="margin-bottom:10px;"></select>
    <table id="allPurchasesTable">
      <thead>
        <tr>
          <th>Date</th><th>Supplier</th><th>Order Number</th>
          <th>Cost Before Discount (€)</th><th>Discount (€)</th><th>Total Cost (€)</th>
        </tr>
      </thead>
      <tbody id="allPurchasesBody"></tbody>
      <tfoot>
        <tr>
          <td colspan="5" style="text-align:right;font-weight:bold;">Total:</td>
          <td id="allPurchasesTotalSum">€0.00</td>
        </tr>
      </tfoot>
    </table>
    <button onclick="closeAllPurchasesModal()">Close</button>
  </div>
</div>

<script>
// Purchase History modal functionality
// Populate month selector and table
function populateAllPurchasesMonths() {
    const monthSel = document.getElementById('allPurchasesMonthSelector');
    if (!monthSel) return;
    monthSel.innerHTML = '';
    const months = [...new Set(transactions.filter(t => t.type === 'purchase').map(t => {
        const [d,m,y] = t.date.split('/');
        return `${y}-${m}`;
    }))].sort();
    months.forEach(mon => {
        const [y,m] = mon.split('-');
        const opt = document.createElement('option');
        opt.value = mon;
        opt.textContent = new Date(y, parseInt(m)-1).toLocaleString('en', { month: 'long', year: 'numeric' });
        monthSel.appendChild(opt);
    });
}

function updateAllPurchasesTable() {
    const monthSel = document.getElementById('allPurchasesMonthSelector');
    const tbody = document.getElementById('allPurchasesBody');
    const totalSumElem = document.getElementById('allPurchasesTotalSum');
    if (!monthSel || !tbody || !totalSumElem) return;
    tbody.innerHTML = '';
    let sum = 0;
    const selected = monthSel.value;
    transactions.filter(t => t.type === 'purchase').filter(t => {
        const [d,m,y] = t.date.split('/');
        return `${y}-${m}` === selected;
    }).sort((a,b) => parseEuropeanDate(b.date) - parseEuropeanDate(a.date))
    .forEach(p => {
        const before = (p.qty || 0) * (p.cost || 0);
        const discount = Math.max(0, before - (p.total || 0));
        sum += p.total || 0;
        const row = tbody.insertRow();
        row.innerHTML = `
            <td>${p.date}</td>
            <td>${p.supplier}</td>
            <td>${p.orderNumber||''}</td>
            <td>${euro.format(before)}</td>
            <td>${euro.format(discount)}</td>
            <td>${euro.format(p.total||0)}</td>
        
          <td><button onclick="openEditPurchaseModal(${JSON.stringify(g.indices)})">Edit</button> <button onclick="deletePurchaseGroup(${JSON.stringify(g.indices)})">Delete</button></td>`
    });
    totalSumElem.textContent = euro.format(sum);
}

function openAllPurchasesModal() {
    populateAllPurchasesMonths();
    const monthSel = document.getElementById('allPurchasesMonthSelector');
    if (monthSel && monthSel.options.length) {
        monthSel.value = monthSel.options[monthSel.options.length - 1].value;
    }
    updateAllPurchasesTable();
    const modal = document.getElementById('allPurchasesModal');
    if (modal) modal.style.display = 'block';
}

function closeAllPurchasesModal() {
    const modal = document.getElementById('allPurchasesModal');
    if (modal) modal.style.display = 'none';
}

document.addEventListener('DOMContentLoaded', function() {
    const btn = document.getElementById('viewMorePurchasesBtn');
    if (btn) btn.addEventListener('click', openAllPurchasesModal);
    const monthSel = document.getElementById('allPurchasesMonthSelector');
    if (monthSel) monthSel.addEventListener('change', updateAllPurchasesTable);
});
</script>


<script>
// Override broken modal functions
(function(){
  function updateAllPurchasesTable() {
    const sel = document.getElementById('allPurchasesMonthSelector');
    const tbody = document.getElementById('allPurchasesBody');
    const totalElem = document.getElementById('allPurchasesTotalSum');
    if (!sel || !tbody || !totalElem) return;
    const mon = sel.value;
    tbody.innerHTML = '';
    let sum = 0;
    // Group by date|supplier|orderNumber
    const groups = {};
    transactions.forEach((p, idx) => {
      if (p.type === 'purchase') {
        const key = `${p.date}|${p.supplier}|${p.orderNumber||''}`;
        if (!groups[key]) groups[key] = { date: p.date, supplier: p.supplier, orderNumber: p.orderNumber||'', items: [], indices: [] };
        groups[key].items.push(p);
        groups[key].indices.push(idx);
      }
    });
    // Filter by month and sort
    Object.keys(groups)
      .filter(key => {
        const [d,m,y] = groups[key].date.split('/');
        return `${y}-${m}` === mon;
      })
      .sort((a,b) => parseEuropeanDate(groups[b].date) - parseEuropeanDate(groups[a].date))
      .forEach(key => {
        const g = groups[key];
        const costBefore = g.items.reduce((s,i) => s + ((i.qty||0)*(i.cost||0)), 0);
        const totalCost = g.items.reduce((s,i) => s + (i.total||0), 0);
        const discount = Math.max(0, costBefore - totalCost);
        sum += totalCost;
        const row = tbody.insertRow();
        row.innerHTML = `
          <td>${g.date}</td>
          <td>${g.supplier}</td>
          <td>${g.orderNumber}</td>
          <td>${euro.format(costBefore)}</td>
          <td>${euro.format(discount)}</td>
          <td>${euro.format(totalCost)}</td>
          <td>
            <button onclick="openEditPurchaseModal(${JSON.stringify(g.indices)})">Edit</button>
            <button onclick="deletePurchaseGroup(${JSON.stringify(g.indices)})">Delete</button>
          </td>`;
      });
    totalElem.textContent = euro.format(sum);
  }

  function openAllPurchasesModal() {
    const sel = document.getElementById('allPurchasesMonthSelector');
    if (!sel) return;
    // Populate months
    const months = [...new Set(transactions.filter(t=>t.type==='purchase').map(t=>{
      const [d,m,y] = t.date.split('/');
      return y+'-'+m;
    }))].sort();
    sel.innerHTML = '';
    months.forEach(mon => {
      const [y,m] = mon.split('-');
      const opt = document.createElement('option');
      opt.value = mon;
      opt.textContent = new Date(y,parseInt(m)-1).toLocaleString('en',{month:'long',year:'numeric'});
      sel.appendChild(opt);
    });
    if (sel.options.length) sel.value = sel.options[sel.options.length-1].value;
    updateAllPurchasesTable();
    document.getElementById('allPurchasesModal').style.display = 'block';
  }

  function closeAllPurchasesModal() {
    document.getElementById('allPurchasesModal').style.display = 'none';
  }

  // Expose globally
  window.updateAllPurchasesTable = updateAllPurchasesTable;
  window.openAllPurchasesModal = openAllPurchasesModal;
  window.closeAllPurchasesModal = closeAllPurchasesModal;

  document.addEventListener('DOMContentLoaded', function(){
    const btn = document.getElementById('viewMorePurchasesBtn');
    if (btn) btn.onclick = openAllPurchasesModal;
    const sel = document.getElementById('allPurchasesMonthSelector');
    if (sel) sel.onchange = updateAllPurchasesTable;
  });
})();
</script>


<script>
// Prevent deleting purchase orders if items have been sold
window.deletePurchaseGroup = function(indices) {
    // indices: array of transaction indices for this purchase order
    // Check each item in the group for any sales
    for (const idx of indices) {
        const purchase = transactions[idx];
        // If no purchase record, skip
        if (!purchase) continue;
        // Find any sale with same item after purchase date
        const purchaseDate = parseEuropeanDate(purchase.date);
        const sold = transactions.some(t => 
            t.type === 'sale' && t.item === purchase.item && parseEuropeanDate(t.date) >= purchaseDate
        );
        if (sold) {
            alert(`Cannot delete purchase for item "${purchase.item}" on ${purchase.date}: item has been sold.`);
            return;
        }
    }
    // Confirm deletion
    if (!confirm('Are you sure you want to delete this purchase order?')) return;
    // Remove in descending order to avoid index shift
    indices.sort((a,b) => b - a).forEach(i => transactions.splice(i, 1));
    saveData();
    updatePurchaseHistoryTable();
    updateAllPurchasesTable();
};
</script>


<script>
// Override updateMonthlySalesTable for grouping & sorting
function updateMonthlySalesTable() {
    const tableBody = document.getElementById('monthlySalesBody');
    const totalSumElement = document.getElementById('monthlySalesTotalSum');
    const monthSelector = document.getElementById('monthSelector');
    if (!tableBody || !totalSumElement || !monthSelector) return;
    // Build header + inputs + button fixed at top
    const inputs = Array.from(document.querySelectorAll('#monthlySalesModal .modal-content > input, #monthlySalesModal .modal-content > select, #monthlySalesModal .modal-content > button[onclick^="addSaleFromModal"]'));
    // Move inputs before tableBody
    const modalContent = document.querySelector('#monthlySalesModal .modal-content');
    inputs.forEach(el => modalContent.insertBefore(el, document.querySelector('#monthlySalesBody').parentElement));
    // Wrap table in modal-body if not already
    let bodyDiv = document.querySelector('#monthlySalesModal .modal-body');
    if (!bodyDiv) {
        const table = document.getElementById('monthlySalesTable');
        bodyDiv = document.createElement('div');
        bodyDiv.className = 'modal-body';
        table.parentNode.insertBefore(bodyDiv, table);
        bodyDiv.appendChild(table);
    }
    // Clear table rows
    tableBody.innerHTML = '';
    const selectedMonth = monthSelector.value;
    if (!selectedMonth) {
        totalSumElement.textContent = euro.format(0);
        return;
    }
    // Filter and sort sales
    const sales = transactions
        .filter(t => t.type === 'sale' && t.date && (() => {
            const [d,m,y] = t.date.split('/');
            return `${y}-${m}` === selectedMonth;
        })())
        .sort((a,b)=> parseEuropeanDate(b.date) - parseEuropeanDate(a.date));
    // Group by date
    const groups = {};
    sales.forEach(s => {
        if (!groups[s.date]) groups[s.date] = [];
        groups[s.date].push(s);
    });
    let totalSum = 0;
    Object.keys(groups)
        .sort((a,b)=> parseEuropeanDate(b) - parseEuropeanDate(a))
        .forEach(date => {
            // date header
            const headerRow = tableBody.insertRow();
            headerRow.classList.add('date-group-header');
            const th = document.createElement('td');
            th.colSpan = 8;
            th.textContent = date;
            headerRow.appendChild(th);
            // rows
            groups[date].forEach(sale => {
                totalSum += sale.total || 0;
                const idx = transactions.indexOf(sale);
                const row = tableBody.insertRow();
                row.innerHTML = `
                    <td><input type="date"
           data-idx="${idx}"
           value="${formatDateForInput(sale.date)}"
           max="${getTodayStrLocal()}"
           oninput="monthlyCellEdited(this)"></td>

                    <td>${sale.item}</td>
                    <td>${sale.mijnTafelName||''}</td>
                    <td><input type="number" min="1"
           data-idx="${idx}"
           value="${sale.qty}"
           oninput="monthlyCellEdited(this)"></td>

                    <td><input type="number" step="0.01" min="0"
           data-idx="${idx}"
           value="${sale.price}"
           oninput="monthlyCellEdited(this)"></td>

                    <td>${euro.format(sale.total)}</td>
                    <td><input type="text"
           data-idx="${idx}"
           value="${sale.tablePlace || ''}"
           oninput="monthlyCellEdited(this)"></td>
                    <td><button onclick="deleteMonthlySale(${idx})">Delete</button></td>
                `;
            });
            // subtotal
            const sub = groups[date].reduce((sum,s)=> sum + (s.total||0), 0);
            const subRow = tableBody.insertRow();
            subRow.innerHTML = `
                <td colspan="5" style="text-align:right;font-weight:bold;">Subtotal for ${date}:</td>
                <td>${euro.format(sub)}</td>
                <td colspan="2"></td>
            `;
        });
    totalSumElement.textContent = euro.format(totalSum);
}
</script>


<script>
// Setup filters for Monthly Sales modal
function setupMonthlySalesFilters() {
    const modal = document.getElementById('monthlySalesModal');
    const inputs = modal.querySelectorAll('.filter-row input');
    inputs.forEach(input => {
        input.addEventListener('input', () => {
            const filters = Array.from(inputs).map(i => i.value.toLowerCase());
            const rows = modal.querySelectorAll('#monthlySalesBody tr');
            rows.forEach(row => {
                let show = true;
                filters.forEach((f, idx) => {
                    if (f && !row.cells[idx].textContent.toLowerCase().includes(f)) {
                        show = false;
                    }
                });
                row.style.display = show ? '' : 'none';
            });
        });
    });
}
document.addEventListener('DOMContentLoaded', setupMonthlySalesFilters);
</script>


<script>
// Setup filters for Inventory tables
document.addEventListener('DOMContentLoaded', () => {
    ['inventoryTable', 'soldOutTable'].forEach(tableId => {
        const table = document.getElementById(tableId);
        if (!table) return;
        const inputs = table.querySelectorAll('thead .filter-row input');
        inputs.forEach((input, idx) => {
            input.addEventListener('input', () => {
                const filter = input.value.toLowerCase();
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const cell = row.cells[idx];
                    row.style.display = cell && cell.textContent.toLowerCase().includes(filter) ? '' : 'none';
                });
            });
        });
    });
});
</script>

<script>


function exportPurchasesData() {
    try {
        const purchases = transactions.filter(t => t.type === 'purchase');
        if (purchases.length === 0) {
            alert('No purchase data to export.');
            return;
        }
        const data = purchases.map(t => {
            const costTotal = (t.cost || 0) * (t.qty || 0);
            return {
                Date: t.date || '',
                Supplier: t.supplier || '',
                OrderNumber: t.orderNumber || '',
                Item: t.item || '',
                MijnTafelName: t.mijnTafelName || '',
                Qty: t.qty || 0,
                CostPerItem: t.cost || 0,
                Cost: costTotal,
                CostAfterDiscount: t.total || 0,
                ItemNetCost: t.total || 0,
                Price: t.price || 0,
                Category: t.category || ''
            };
        });
        const ws = XLSX.utils.json_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Purchases');
        const dateStr = new Date().toISOString().slice(0,10);
        const filename = 'shop_tracker_purchases_' + dateStr + '.xlsx';
        XLSX.writeFile(wb, filename);
        alert('Purchases data exported successfully as ' + filename);
    } catch (e) {
        console.error('Error exporting purchases data:', e);
        alert('An error occurred while exporting purchases data.');
    }
}

// Open Rental Payment Modal
function openAddRentalPaymentModal() {
    const modal = document.getElementById('rentalPaymentModal');
    if (modal) {
        modal.style.display = 'block'; // Show the modal
    }
}

// Close Rental Payment Modal
function closeRentalPaymentModal() {
    const modal = document.getElementById('rentalPaymentModal');
    if (modal) {
        modal.style.display = 'none'; // Hide the modal
    }
}

// Save Rental Payment (add your save logic here)
function saveRentalPayment() {
    try {
        const amount = document.getElementById('rentalAmount').value;
        const date = document.getElementById('rentalDate').value;
        const period = document.getElementById('rentalPeriod').value;
        const duration = document.getElementById('rentalDuration').value;
        const tablePlace = document.getElementById('rentalTablePlace').value;
        const comments = document.getElementById('rentalComments').value;

        if (!amount || !date || !period || !duration) {
            alert('Please fill out all required fields.');
            return;
        }

        if (!Array.isArray(window.rentalPayments)) {
            window.rentalPayments = [];
        }

        const newPayment = {
            tablePlace,
            paymentDate: date,
            rentalPeriod: period,
            duration,
            amount: parseFloat(amount),
            comments
        };

        window.rentalPayments.push(newPayment);

        saveData(); // POSTs to /save via your backend
        closeRentalPaymentModal();
        loadRentalPayments();
    } catch (e) {
        console.error('❌ Error in saveRentalPayment:', e);
        alert('Failed to save rental payment. See console for details.');
    }
}


// Update Rental Period and Duration based on selected start and end date
function updateRentalPeriod() {
    const rentalPeriodStart = document.getElementById('rentalPeriodStart').value;
    const rentalPeriodEnd = document.getElementById('rentalPeriodEnd').value;

    if (!rentalPeriodStart || !rentalPeriodEnd) return;

    const startDate = new Date(rentalPeriodStart);
    const endDate = new Date(rentalPeriodEnd);

    // Format the dates as "DD/MM/YYYY"
    const rentalPeriod = `${formatDate(startDate)} - ${formatDate(endDate)}`;
    document.getElementById('rentalPeriod').value = rentalPeriod;

    // Calculate working days between start and end date
    const duration = calculateWorkingDays(startDate, endDate);
    document.getElementById('rentalDuration').value = duration;
}

// Format date to DD/MM/YYYY
function formatDate(date) {
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
}

// Calculate working days (Tuesday to Saturday)
function calculateWorkingDays(startDate, endDate) {
    const holidays = []; // List of holiday dates to exclude (in format "DD/MM/YYYY")

    let workingDays = 0;

    // Loop through all days between start and end date
    while (startDate <= endDate) {
        const dayOfWeek = startDate.getDay(); // Get day of week (0 = Sunday, 1 = Monday, etc.)
        
        // Check if the day is a working day (Tuesday = 2, Wednesday = 3, ..., Saturday = 6)
        if (dayOfWeek >= 2 && dayOfWeek <= 6) {
            const formattedDate = formatDate(startDate);
            if (!holidays.includes(formattedDate)) {
                workingDays++;
            }
        }
        
        // Move to the next day
        startDate.setDate(startDate.getDate() + 1);
    }

    return workingDays;
}

// Set date limits (ensure future dates are allowed only for the rental period)
function setDateLimits() {
    const today = new Date().toISOString().split('T')[0]; // Get today's date in YYYY-MM-DD format
    document.getElementById('rentalDate').max = today; // Prevent future dates for Payment Date
    document.getElementById('rentalPeriodStart').min = ''; // Allow any dates for Rental Period Start
    document.getElementById('rentalPeriodEnd').min = ''; // Allow any dates for Rental Period End
}


</script>

<script>
// Initialize the line number for the table
let rentalPaymentCounter = 1;

// Open Rental Payment Modal
function openAddRentalPaymentModal() {
    const modal = document.getElementById('rentalPaymentModal');
    if (modal) {
        modal.style.display = 'block'; // Show the modal
    }
}

// Close Rental Payment Modal
function closeRentalPaymentModal() {
    const modal = document.getElementById('rentalPaymentModal');
    if (modal) {
        modal.style.display = 'none'; // Hide the modal
    }
}

// Close Edit Rental Payment Modal
function closeEditRentalPaymentModal() {
    const modal = document.getElementById('editRentalPaymentModal');
    if (modal) modal.style.display = 'none';
}

// Open Edit Rental Payment Modal
function openEditRentalPaymentModal(index) {
    const payment = window.rentalPayments?.[index];
    if (!payment) {
        alert('Error: Rental payment not found.');
        return;
    }

    document.getElementById('editRentalPaymentIndex').value = index;
    document.getElementById('editRentalTablePlace').value = payment.tablePlace || '';
    document.getElementById('editRentalDate').value = payment.paymentDate ? formatDateForInput(payment.paymentDate) : '';

    if (payment.rentalPeriod?.includes(' - ')) {
        const [start, end] = payment.rentalPeriod.split(' - ');
        document.getElementById('editRentalPeriodStart').value = formatDateForInput(start);
        document.getElementById('editRentalPeriodEnd').value = formatDateForInput(end);
    }

    document.getElementById('editRentalPeriod').value = payment.rentalPeriod || '';
    document.getElementById('editRentalDuration').value = payment.duration || '';
    document.getElementById('editRentalAmount').value = payment.amount || '';
    document.getElementById('editRentalComments').value = payment.comments || '';

    setDateLimits();
    const modal = document.getElementById('editRentalPaymentModal');
    if (modal) modal.style.display = 'block';
}


// Update Rental Period and Duration for Edit Modal
function updateEditRentalPeriod() {
    const startDateStr = document.getElementById('editRentalPeriodStart').value;
    const endDateStr = document.getElementById('editRentalPeriodEnd').value;

    if (!startDateStr || !endDateStr) return;

    const startDate = new Date(startDateStr);
    const endDate = new Date(endDateStr);

    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return;

    const rentalPeriod = `${formatDate(startDate)} - ${formatDate(endDate)}`;
    document.getElementById('editRentalPeriod').value = rentalPeriod;

    const duration = calculateWorkingDays(startDate, endDate);
    document.getElementById('editRentalDuration').value = duration;
}

// Save Edited Rental Payment
function saveEditedRentalPayment() {
    const index = parseInt(document.getElementById('editRentalPaymentIndex').value);
    const tablePlace = document.getElementById('editRentalTablePlace').value.trim();
    const paymentDate = document.getElementById('editRentalDate').value;
    const rentalPeriodStart = document.getElementById('editRentalPeriodStart').value;
    const rentalPeriodEnd = document.getElementById('editRentalPeriodEnd').value;
    const rentalPeriod = document.getElementById('editRentalPeriod').value;
    const duration = document.getElementById('editRentalDuration').value;
    const amount = document.getElementById('editRentalAmount').value;
    const comments = document.getElementById('editRentalComments').value.trim();

    if (!tablePlace || !paymentDate || !rentalPeriodStart || !rentalPeriodEnd || !amount) {
        alert('Please fill out all required fields.');
        return;
    }

    const paymentDateObj = new Date(paymentDate);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    if (paymentDateObj > today) {
        alert('Payment date cannot be in the future.');
        return;
    }

    const startDate = new Date(rentalPeriodStart);
    const endDate = new Date(rentalPeriodEnd);
    if (startDate > endDate) {
        alert('Rental period end date must be after start date.');
        return;
    }

    if (!Array.isArray(window.rentalPayments)) {
        console.error("No rentalPayments array available.");
        return;
    }

    const updatedPayment = {
        lineNumber: index + 1,
        tablePlace,
        paymentDate: formatDate(paymentDateObj),
        rentalPeriod,
        duration,
        amount,
        comments
    };

    try {
        window.rentalPayments[index] = updatedPayment;

        // Update line numbers
        window.rentalPayments.forEach((p, i) => p.lineNumber = i + 1);

        saveData();           // backend save
        loadRentalPayments(); // reload UI
        closeEditRentalPaymentModal();
    } catch (e) {
        console.error("❌ Failed to edit rental payment:", e);
        alert("Error editing payment. See console for details.");
    }
}


// Delete Rental Payment
function deleteRentalPayment(index) {
    if (!Array.isArray(window.rentalPayments)) {
        console.warn('No rental payments to delete from.');
        return;
    }

    if (!confirm("Are you sure you want to delete this rental payment?")) return;

    try {
        window.rentalPayments.splice(index, 1); // Remove from array

        // Recalculate line numbers
        window.rentalPayments.forEach((payment, i) => {
            payment.lineNumber = i + 1;
        });

        saveData();         // Save to backend
        loadRentalPayments(); // Refresh table
    } catch (e) {
        console.error("❌ Failed to delete rental payment:", e);
        alert("Failed to delete payment. See console for details.");
    }
}


// Save Rental Payment
function saveRentalPayment() {
    const amount = document.getElementById('rentalAmount').value;
    const date = document.getElementById('rentalDate').value;
    const period = document.getElementById('rentalPeriod').value;
    const duration = document.getElementById('rentalDuration').value;
    const tablePlace = document.getElementById('rentalTablePlace').value;
    const comments = document.getElementById('rentalComments').value;

    if (!amount || !date || !period || !duration) {
        alert('Please fill out all required fields.');
        return;
    }

    if (!Array.isArray(window.rentalPayments)) {
        window.rentalPayments = [];
    }

    const newPayment = {
        lineNumber: window.rentalPayments.length + 1,
        tablePlace,
        paymentDate: formatDate(new Date(date)),
        rentalPeriod: period,
        duration,
        amount,
        comments
    };

    window.rentalPayments.push(newPayment);

    saveData();            // 🔁 Save full app state to backend
    loadRentalPayments();  // ♻️ Update table
    closeRentalPaymentModal();

    console.log('✅ Rental Payment saved to backend:', newPayment);
}

// Update Rental Period and Duration based on selected start and end date
function updateRentalPeriod() {
    const rentalPeriodStart = document.getElementById('rentalPeriodStart').value;
    const rentalPeriodEnd = document.getElementById('rentalPeriodEnd').value;

    if (!rentalPeriodStart || !rentalPeriodEnd) return;

    const startDate = new Date(rentalPeriodStart);
    const endDate = new Date(rentalPeriodEnd);

    // Format the dates as "DD/MM/YYYY"
    const rentalPeriod = `${formatDate(startDate)} - ${formatDate(endDate)}`;
    document.getElementById('rentalPeriod').value = rentalPeriod;

    // Calculate working days between start and end date
    const duration = calculateWorkingDays(startDate, endDate);
    document.getElementById('rentalDuration').value = duration;
}

// Format date to DD/MM/YYYY
function formatDate(date) {
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
}

// Format date for input (YYYY-MM-DD)
function formatDateForInput(dateStr) {
    const [day, month, year] = dateStr.split('/');
    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
}

// Calculate working days (Tuesday to Saturday)
function calculateWorkingDays(startDate, endDate) {
    const holidays = [];
    let workingDays = 0;

    while (startDate <= endDate) {
        const dayOfWeek = startDate.getDay();
        if (dayOfWeek >= 2 && dayOfWeek <= 6) {
            const formattedDate = formatDate(startDate);
            if (!holidays.includes(formattedDate)) {
                workingDays++;
            }
        }
        startDate.setDate(startDate.getDate() + 1);
    }

    return workingDays;
}

// Set date limits
function setDateLimits() {
    const today = new Date().toISOString().split('T')[0];
    document.getElementById('rentalDate').max = today;
    document.getElementById('editRentalDate').max = today;
    document.getElementById('rentalPeriodStart').min = '';
    document.getElementById('rentalPeriodEnd').min = '';
    document.getElementById('editRentalPeriodStart').min = '';
    document.getElementById('editRentalPeriodEnd').min = '';
}

// Load rental payments from localStorage and display them in the table
function loadRentalPayments() {
console.log("🔁 loadRentalPayments: window.rentalPayments =", window.rentalPayments);

    try {
        const storedPayments = Array.isArray(window.rentalPayments) ? window.rentalPayments : [];
        const table = document.getElementById('rentalPaymentTable').getElementsByTagName('tbody')[0];
        if (!table) {
            console.error('Table body not found for rentalPaymentTable');
            alert('Error: Table not found. Check the HTML structure.');
            return;
        }
        table.innerHTML = '';

        console.log('✅ Rental Payments loaded from backend state:', storedPayments);

        // Sort payments by paymentDate in descending order
        storedPayments.sort((a, b) => {
            // Default to a far future date if paymentDate is invalid to push invalid entries to the bottom
            const defaultDate = new Date('9999-12-31');
            let dateA = defaultDate;
            let dateB = defaultDate;

            try {
                if (a.paymentDate && typeof a.paymentDate === 'string' && a.paymentDate.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                    const [dayA, monthA, yearA] = a.paymentDate.split('/').map(Number);
                    dateA = new Date(yearA, monthA - 1, dayA);
                    if (isNaN(dateA.getTime())) {
                        console.warn('Invalid date for payment A:', a.paymentDate);
                        dateA = defaultDate;
                    }
                } else {
                    console.warn('Missing or invalid paymentDate for payment A:', a);
                }
            } catch (e) {
                console.error('Error parsing date for payment A:', e, a);
            }

            try {
                if (b.paymentDate && typeof b.paymentDate === 'string' && b.paymentDate.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                    const [dayB, monthB, yearB] = b.paymentDate.split('/').map(Number);
                    dateB = new Date(yearB, monthB - 1, dayB);
                    if (isNaN(dateB.getTime())) {
                        console.warn('Invalid date for payment B:', b.paymentDate);
                        dateB = defaultDate;
                    }
                } else {
                    console.warn('Missing or invalid paymentDate for payment B:', b);
                }
            } catch (e) {
                console.error('Error parsing date for payment B:', e, b);
            }

            return dateB - dateA; // Descending order (most recent first)
        });

        // Update lineNumber based on sorted order
        storedPayments.forEach((payment, index) => {
            payment.lineNumber = index + 1;
        });

        console.log('Sorted payments:', storedPayments);

        // Render all payments
        storedPayments.forEach((payment, index) => {
            try {
                const newRow = table.insertRow();
                newRow.insertCell(0).textContent = payment.lineNumber || index + 1;
                newRow.insertCell(1).textContent = payment.tablePlace || '';
                newRow.insertCell(2).textContent = payment.paymentDate || '';
                newRow.insertCell(3).textContent = payment.rentalPeriod || '';
                newRow.insertCell(4).textContent = payment.duration || '';
                newRow.insertCell(5).textContent = payment.amount ? euro.format(parseFloat(payment.amount)) : '';
                newRow.insertCell(6).textContent = payment.comments || '';
                const actionsCell = newRow.insertCell(7);
                actionsCell.innerHTML = `
                    <button onclick="openEditRentalPaymentModal(${index})">Edit</button>
                    <button onclick="deleteRentalPayment(${index})">Delete</button>
                `;
            } catch (e) {
                console.error('Error rendering payment row:', e, { payment });
            }
        });

              rentalPaymentCounter = storedPayments.length + 1;
    } catch (e) {
        console.error('Error in loadRentalPayments:', e);
        alert('Failed to load rental payments. Check the console for details.');
    }
}

// Load rental payments when the page loads
function onAppReady() {
   
    // Any other things you want after data/UI is ready
}



/* When the page finishes loading, pre-fill the Sale date box */
document.addEventListener('DOMContentLoaded', () => {
    const saleDateInput = document.getElementById('saleDate');
    if (saleDateInput) {
        saleDateInput.value = lastMainSaleDate || getTodayStrLocal();
        setDateLimits();                         // keeps the max="today"
    }
});

</script>

<!-- Add Prints Modal -->
<div id="addPrintsModal" class="modal">
    <div class="modal-content">
      <h2>Select 3D Prints</h2>
  
      <label style="display: inline-block; margin-bottom: 10px;">
        Date: <input type="date" id="addPrintsDate" style="width: 200px;" />
      </label>
  
      <table id="addPrintsTable" border="1" style="width: 100%; margin-top: 10px;">
        <thead>
          <tr>
            <th>#</th><th>Name</th><th>Description</th>
            <th>Qty</th><th>Cost per Item (€)</th><th>Total Cost (€)</th>
            <th>Price (€)</th><th>Chk</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
  
      <div style="margin-top: 10px; text-align: right;">
        <button onclick="closeAddPrintsModal()">Cancel</button>
        <button id="confirmAddPrintsBtn" onclick="confirmAddPrints()" disabled>Add Prints</button>
      </div>
    </div>
  </div>
  
  
  <script>
    document.getElementById('openAddPrintsModalBtn').addEventListener('click', () => {
  fetchLatestPrintsStock().then(() => openAddPrintsModal());
});

    
    function openAddPrintsModal() {
      const modal = document.getElementById('addPrintsModal');
      const tbody = modal.querySelector('tbody');
      const dateInput = document.getElementById('addPrintsDate');
      const confirmBtn = document.getElementById('confirmAddPrintsBtn');
    
      tbody.innerHTML = '';
      confirmBtn.disabled = true;
      dateInput.value = new Date().toISOString().split('T')[0];
    
      const prints = (window._prints || []).map((p, i) => {
        const productionCost = (p.avgPricePerKg || 0) * (p.weight || 0) / 1000 * (p.qty || 1);
        const cost = productionCost + (parseFloat(p.componentsCost) || 0);
        const costPerItem = cost / (p.qty || 1);
        return { ...p, totalCost: cost.toFixed(2), costPerItem: costPerItem.toFixed(2), index: i + 1 };
      });
    
      prints.forEach(p => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${p.index}</td>
          <td>${p.name || ''}</td>
          <td>${p.description || ''}</td>
          <td><input type="number" class="qtyInput" min="1" max="${p.qty}" value="${p.qty}" data-index="${p.index}" style="width: 60px;"></td>
          <td>${p.costPerItem}</td>
          <td>${p.totalCost}</td>
          <td>${p.price}</td>
          <td style="text-align: center;">
            <input type="checkbox" class="addPrintsCheck" style="width: 18px; height: 18px; visibility: visible;">
            </td>

        `;
        const qtyInput = row.querySelector('.qtyInput');
        qtyInput.addEventListener('input', () => {
        const qty = parseInt(qtyInput.value, 10) || 0;
        const maxQty = parseInt(qtyInput.max, 10) || 0;

        if (qty < 1 || qty > maxQty) return;

        const avgPricePerKg = parseFloat(p.avgPricePerKg) || 0;
        const weight = parseFloat(p.weight) || 0;
        const componentsCost = parseFloat(p.componentsCost) || 0;

        const productionCost = avgPricePerKg * weight / 1000 * qty;
        const cost = productionCost + componentsCost;

        const costPerItem = cost / qty;

        // Update table cells
        row.cells[4].textContent = costPerItem.toFixed(2);  // Cost per item
        row.cells[5].textContent = cost.toFixed(2);         // Total cost
        });
        tbody.appendChild(row);
      });
    
      tbody.querySelectorAll('.addPrintsCheck').forEach(chk => {
        chk.addEventListener('change', () => {
          confirmBtn.disabled = !tbody.querySelector('.addPrintsCheck:checked');
        });
      });
    
      modal.style.display = 'block';
    }
    
    function fetchLatestPrintsStock() {
  return fetch('/data/3d')
    .then(res => res.json())
    .then(data => {
      if (Array.isArray(data.prints)) {
        window._prints = data.prints;
        return data.prints;
      }
      return [];
    })
    .catch(err => {
      console.error("❌ Failed to load prints:", err);
      alert("Could not fetch latest prints stock.");
      return [];
    });
    }

    function closeAddPrintsModal() {
      document.getElementById('addPrintsModal').style.display = 'none';
    }
    
    function confirmAddPrints() {
  if (!Array.isArray(transactions)) transactions = [];

  const rawDate = document.getElementById('addPrintsDate').value;
  if (!rawDate) return;

  const [yyyy, mm, dd] = rawDate.split('-');
  const date = `${dd}/${mm}/${yyyy}`;

  const table = document.getElementById('addPrintsTable').querySelector('tbody');
  const checkedRows = table.querySelectorAll('input[type="checkbox"]:checked');
  if (!checkedRows.length) return;

  const orderNumber = getNextOrderNumber().toString();

  checkedRows.forEach(row => {
    const cells = row.closest('tr').cells;
    const qtyInput = cells[3].querySelector('input');
    const qty = parseInt(qtyInput?.value, 10) || 0;
    const maxQty = parseInt(qtyInput?.max, 10);

    if (qty <= 0 || qty > maxQty) {
    console.warn("❌ Skipped due to invalid qty:", qty, "for row:", row);
    return;
    }
    const total = +cells[5]?.textContent.trim() || 0;
    const cost = qty > 0 ? total / qty : 0;
    const price = +cells[6]?.textContent.trim() || 0;
    const item = cells[2]?.textContent.trim();
    const mijnTafelName = cells[1]?.textContent.trim();

    if (!item || !mijnTafelName || !qty || !cost) {
      console.warn("❌ Skipped invalid print row:", row);
      return;
    }

    transactions.push({
        category: "3D Prints",
        cost,                  // ✅ unit cost
        date,
        item,
        mijnTafelName,
        orderNumber,
        price,
        qty,
        supplier: "3D_Fabriek",
        total,                 // ✅ total cost (qty * cost)
        type: "purchase"
    });
  });

  saveData();
  updatePurchaseHistoryTable();
  closeAddPrintsModal();
}


function getNextOrderNumber() {
  const nums = transactions.map(t => +t.orderNumber).filter(n => !isNaN(n));
  return nums.length ? Math.max(...nums) + 1 : 1;
}

    </script>    

<script>
    window.addPrintsToPurchase = function(prints) {
      if (!Array.isArray(prints) || prints.length === 0) return;
    
      const history = window.transactions || [];
      const nextOrderNum = (() => {
        const existing = history.filter(t => t.type === 'purchase' && t.orderNumber)
          .map(t => parseInt(t.orderNumber)).filter(n => !isNaN(n));
        return existing.length > 0 ? Math.max(...existing) + 1 : 1;
      })();
    
      const newPurchases = prints.map(p => ({
        type: 'purchase',
        date: p.date,
        supplier: p.supplier,
        orderNumber: nextOrderNum.toString(),
        discount: '', // blank
        item: p.description,
        name: p.name,
        qty: p.qty,
        costPerItem: p.costPerItem,
        cost: p.cost,
        costAfterDiscount: p.cost, // same as cost
        netCost: p.cost,           // same as cost
        price: p.price,
        category: p.category
      }));
    
      // Add to memory + save + refresh UI
      window.transactions = [...history, ...newPurchases];
      saveData();           // this should exist in your script
      updatePurchaseUI();   // if it exists to refresh tables
      console.log(`✅ Added ${newPurchases.length} print(s) as purchase(s)`);
    };
    </script>
    
    <script>
        function renderAddPrintsTable() {
          const tbody = document.querySelector('#addPrintsTable tbody');
          tbody.innerHTML = '';
        
          const prints = window._prints || [];
          if (!Array.isArray(prints)) return;
        
          prints.forEach((p, index) => {
            const row = tbody.insertRow();
        
            // #
            row.insertCell().textContent = index + 1;
            // Name
            row.insertCell().textContent = p.name || '';
            // Description
            row.insertCell().textContent = p.description || '';
            // Qty
            row.insertCell().textContent = p.qty || 0;
            // Cost per Item = Total Cost / Qty
            const total = parseFloat(p.productionCost || 0) + parseFloat(p.componentsCost || 0);
            const costPerItem = p.qty ? total / p.qty : 0;
            row.insertCell().textContent = costPerItem.toFixed(2);
            // Total Cost
            row.insertCell().textContent = total.toFixed(2);
            // Price
            row.insertCell().textContent = p.price || 0;
        
            // Checkbox
            const chk = document.createElement('input');
            chk.type = 'checkbox';
            chk.dataset.index = index;
            chk.addEventListener('change', updateAddPrintsBtnState);
        
            const chkCell = row.insertCell();
            chkCell.appendChild(chk);
          });
        }
        
        function updateAddPrintsBtnState() {
          const anyChecked = !!document.querySelector('#addPrintsTable tbody input[type="checkbox"]:checked');
          document.getElementById('confirmAddPrintsBtn').disabled = !anyChecked;
        }
        </script>
        
        <script>
            function preloadPrintsFromBackend() {
              fetch('/data/3d')
                .then(res => res.json())
                .then(data => {
                  const items = Array.isArray(data.prints) ? data.prints : [];
                  window._prints = items;
                  console.log(`✅ Loaded ${items.length} prints into memory`);
                })
                .catch(err => {
                  console.error('❌ Failed to load prints:', err);
                });
            }
          
            // Run this when page loads
            document.addEventListener('DOMContentLoaded', preloadPrintsFromBackend);
          </script>
          
        <script>
          

function addPurchaseRow({ date, supplier, orderNumber, items }) {
  if (!Array.isArray(items)) {
    console.error("❌ Invalid or missing purchase items:", items);
    return;
  }

  const tbody = document.getElementById("purchaseHistoryBody");

  const costBeforeDiscount = items.reduce((sum, i) => sum + i.cost, 0);
  const discount = 0;
  const totalCost = costBeforeDiscount - discount;

  const row = document.createElement("tr");
  row.innerHTML = `
    <td>${date}</td>
    <td>${supplier}</td>
    <td>${orderNumber}</td>
    <td>${costBeforeDiscount.toFixed(2)}</td>
    <td>${discount.toFixed(2)}</td>
    <td>${totalCost.toFixed(2)}</td>
    <td>
      <button onclick="editPurchase(${orderNumber})">Edit</button>
      <button onclick="deletePurchase(${orderNumber})">Delete</button>
    </td>
  `;
  tbody.appendChild(row);

  window._purchaseData = window._purchaseData || {};
  window._purchaseData[orderNumber] = {
    date,
    supplier,
    orderNumber,
    items,
    costBeforeDiscount,
    discount,
    totalCost
  };
}


document.addEventListener('DOMContentLoaded', updatePurchaseHistoryTable);

function openItemDetailsModal(itemName, mijnTafelName) {
    // Remember which item this modal is showing
  const detailModal = document.getElementById('itemDetailsModal');
  detailModal.dataset.itemName       = itemName;
  detailModal.dataset.mijnTafelName  = mijnTafelName;
   
    // --> initialize sales aggregates
    let qtyTotal = 0;
    // 1) Header — split into three fields
   document.getElementById('itemDetailsName').textContent = itemName;
  document.getElementById('itemDetailsMijn').textContent = mijnTafelName;
  document.getElementById('itemDetailsQty').textContent  = inventory[itemName] || 0;

  // 2) Purchases
  const pRows = transactions
    .filter(t => t.type==='purchase' && t.item===itemName)
    .sort((a,b)=> parseEuropeanDate(a.date) - parseEuropeanDate(b.date));
  const pBody = document.querySelector('#itemDetailsPurchasesTable tbody');
  pBody.innerHTML = '';
  let pSubtotal = 0;
  pRows.forEach(p => {
  // compute all purchase indices for this Order Number
  const groupIndices = transactions.reduce((arr, t, i) => {
    if (t.type==='purchase' && t.orderNumber === p.orderNumber) arr.push(i);
    return arr;
  }, []);
  const netUnit = p.total / p.qty;
  pSubtotal += p.total;
  const r = pBody.insertRow();
  r.innerHTML = `
    <td>${p.date}</td>
    <td>${p.supplier}</td>
    <td>
      <a href="javascript:"
         onclick='openEditPurchaseModal(${JSON.stringify(groupIndices)})'>
        ${p.orderNumber}
      </a>
    </td>
    <td>${p.qty}</td>
    <td>${euro.format(netUnit)}</td>
    <td>${euro.format(p.total)}</td>
  `;
});

  document.getElementById('itemDetailsPurchaseSubtotal')
          .textContent = euro.format(pSubtotal);

  // 3) Sales
  const sRows = transactions
    .filter(t => t.type==='sale' && t.item===itemName)
    .sort((a,b)=> parseEuropeanDate(a.date) - parseEuropeanDate(b.date));
  const sBody = document.querySelector('#itemDetailsSalesTable tbody');
  sBody.innerHTML = '';
  let sTotal = 0, gmTotal = 0;
  sRows.forEach(s => {
    // 1) accumulate qty
    qtyTotal += s.qty;

    // 2) find the most recent purchase net‐unit‐cost on or before the sale date
    const prevPurchases = transactions
      .filter(t => t.type==='purchase'
                && t.item===itemName
                && parseEuropeanDate(t.date) <= parseEuropeanDate(s.date))
      .sort((a,b)=> parseEuropeanDate(b.date) - parseEuropeanDate(a.date));
    const netUnitCost = prevPurchases.length
      ? prevPurchases[0].total / prevPurchases[0].qty
      : 0;

    // 3) compute gross margin correctly
    const grossM = (s.price - netUnitCost) * s.qty;
    sTotal  += s.total;
    gmTotal += grossM;

    // 4) render row with swapped Price/Qty columns
    const r = sBody.insertRow();
    r.innerHTML = `
      <td>${s.date}</td>
      <td>${euro.format(s.price)}</td>
      <td>${s.qty}</td>
      <td>${euro.format(s.total)}</td>
      <td>${euro.format(grossM)}</td>
      <td>${s.tablePlace||''}</td>
    `;
  });
    // write out the new Qty total
    document.getElementById('itemDetailsSalesTotalQty')
            .textContent = qtyTotal;

  document.getElementById('itemDetailsSalesTotal')
          .textContent = euro.format(sTotal);
  document.getElementById('itemDetailsGrossMarginTotal')
          .textContent = euro.format(gmTotal);

  // 4) Cash Flow
  const cashFlow = sTotal - pSubtotal;
  const cashEl   = document.getElementById('itemDetailsCashFlow');
  cashEl.textContent = euro.format(cashFlow);
  // color red if negative, green if positive
  cashEl.style.color = cashFlow < 0 ? 'red' : 'green';

  // Show it
  document.getElementById('itemDetailsModal').style.display = 'block';
}



        </script>
          
</div>

  <!-- add a second panel that will host 3d_fabriek.html via iframe -->
  <div id="fabriekPanel" style="display:none; width:100%; height:100%;">
    <iframe
      src="/3d"
      frameborder="0"
      scrolling="yes"
      style="width:100%; height:100%;"
      title="3D_Fabriek">
    </iframe>
</div>

</div>  <!-- closes #mainContent wrapper -->
</body>
</html>